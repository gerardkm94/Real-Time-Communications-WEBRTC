\section{JavaScript}

\subsection{Introducción}
\begin{frame}[fragile]\frametitle{¿Qué es JavaScript?}
\begin{itemize}
\small
\item \textbf{JavaScript} es un lenguaje de programación interpretado:
  \begin{itemize}
  \footnotesize
  \item No es necesario compilar los programas para ejecutarlos porque es un lenguaje de programación interpretado.
  \item Los programas escritos con JavaScript se pueden probar directamente en cualquier 
  navegador sin necesidad de procesos intermedios.
  \end{itemize} 
\item Proviene de un dialecto del estándar ECMAScript.
\item Java y JavaScript no están relacionados y tienen semánticas y propósitos diferentes.
\item Se define como orientado a objetos, basado en prototipos, imperativo, débilmente tipado y dinámico.
\item Usos:
  \begin{itemize}
  \footnotesize
  \item Se utiliza principalmente en el lado del cliente en servicios Web, 
  implementado como parte de un navegador web permitiendo crear interacción con el usuario y páginas web dinámicas.
  \item Aunque actualmente es posible ejecutar JavaScript en el propio servidor mediante NodeJS.
  \end{itemize}
\end{itemize} 
\end{frame}

\begin{frame}[fragile]\frametitle{Glosario Básico}
\begin{itemize}
 \item \textbf{Script}: Cada uno de los programas, aplicaciones o trozos de código 
 creados con el lenguaje de programación JavaScript.
 \item \textbf{Sentencia}: Cada una de las instrucciones que forman un script.
 \item \textbf{Palabras reservadas}: Son las palabras (en inglés) que se utilizan 
 para construir las sentencias de JavaScript. 
  \begin{itemize}
  \item Las palabras reservadas no pueden ser utilizadas en el código.
  \item Ejemplos: break, case, catch, continue, default, delete, do, if, etc.
  \end{itemize}

\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Sintaxis}
% La sintaxis de JavaScript es muy similar a la de otros lenguajes de programación 
% como C.
Normas básicas de la sintaxis JS:
   \begin{enumerate}
   \item No se tienen en cuenta los espacios en blanco ni los saltos de línea.
   \item Se distinguen las mayúsculas y minúsculas.
   \item No se define el tipo de las variables (no es necesario indicar 
   el tipo de dato que almacenará la variable). 
   \item No es obligatorio terminar cada sentencia Javascript con punto 
   y coma \textbf{(;)} (aunque se considera una buena prática utilizar el punto 
   y coma para finalizar las sentencias Javascript).
   \item Se pueden incluir comentarios de dos tipos:
    \begin{itemize}
     \item Los de una sola línea: se definen añadiendo dos barras oblicuas 
     al principio del comentario \textit{//comentario}.
     \item Los que ocupan varias líneas: se definen encerrando el texto del comentario 
     entre los símbolos \textit{ /* ...... */}
    \end{itemize}
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]\frametitle{¿Cómo incluir JavaScript en documentos XHTML?}
\begin{itemize}
\item La integración de JavaScript y XHTML es muy flexible.
\item Existen esencialmente tres formas para incluir código JavaScript 
en las páginas XHTML:
\end{itemize}

\vspace{0.3cm}
  \begin{enumerate}
  \item Incluir JavaScript en el mismo documento XHTML.
  \item Definir JavaScript en un archivo externo y enlazarlo en el XHTML.
  \item Incluir JavaScript en los elementos del XHTML.
  \end{enumerate}

\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{JS en documentos XHTML}
\begin{itemize}
 \item El código JavaScript se encierra entre etiquetas \textbf{<script>} y se incluye en cualquier parte del documento.
 \item Aunque es correcto incluir cualquier bloque de código en cualquier zona de la página, se recomienda definir el código JavaScript dentro de la cabecera del documento (dentro de la etiqueta \textbf{<head>)}:
 \begin{lstlisting}[style=JavaScriptTiny]
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Ejemplo de codigo JavaScript en el propio documento</title>
<script type="text/javascript">
  alert("Un mensaje de prueba");
</script>
</head>
<body>
<p>Un texto.</p>
</body>
</html>
 \end{lstlisting}
\item Para que la página XHTML resultante sea válida, es necesario añadir 
el atributo type a la etiqueta <script>. 
\item Técnicamente, el atributo type se corresponde con el tipo ``MIME`` 
(estándar para identificar los diferentes tipos de contenidos). 
\item El tipo MIME para JavaScript es \textbf{text/javascript}.
\item Este método se utiliza habitualmente cuando:
  \begin{itemize}
  \item Sólo es necesario definir pequeño bloque de código. 
  \item Se quieren incluir instrucciones específicas para un determinado 
  documento XHTML (no reutilizables).
  \item El principal inconveniente es que si se quiere hacer una modificación 
  en el bloque de código, es necesario modificar cada páginas 
  que incluya el código JavaScript.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{JS en un Archivo}
\begin{itemize}
\item Las instrucciones JavaScript se pueden incluir en un archivo externo mediante 
la etiqueta \textbf{<script>}.
\item Ejemplo para enlazar un archivo en un documento XHTML:
  \begin{lstlisting}[style=JavaScriptTiny]
  <html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <title>Ejemplo de codigo JavaScript en el propio documento</title>
  <script type="text/javascript" src="/js/codigo.js"></script>
  </head> 
  <body>
  <p>Un texto.</p>
  </body>
  </html>
  \end{lstlisting}
\item El archivo \textbf{codigo.js} podría contener la siguiente instrucción:
\begin{lstlisting}[style=JavaScriptTiny]
alert("Un mensaje de prueba");
\end{lstlisting}

\item Además del atributo type, este método requiere definir el atributo \textbf{src}
con la URL del archivo.
\item Cada etiqueta <script> solamente puede enlazar un único archivo.
\item En una misma página se pueden incluir tantas etiquetas <script> como sean necesarias.
\item Los archivos JavaScript son documentos normales (se pueden crear con cualquier editor 
de texto o con entornos de desarrollo) con la extensión \textbf{.js}.
\item La principales ventajas de enlazar archivos JavaScript son que:
  \begin{enumerate}
  \item Se simplifica el código XHTML de la página.
  \item Se puede reutilizar el mismo código JavaScript.
  \end{enumerate}
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{JS en Elementos XHTML}
\begin{itemize}
\item Consiste en incluir código JavaScript en el código XHTML:
\begin{lstlisting}[style=JavaScriptTiny]
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Ejemplo de codigo JavaScript en el propio documento</title>
</head>
<body>
<p onclick="alert('Un mensaje de prueba')">Presionar.</p>
</body>
</html>
\end{lstlisting}
\item Los mayores inconvenientes de este método son que: 
  \begin{enumerate}
  \item 'Ensucia' el código XHTML.
  \item Complica el mantenimiento (no fomenta la reutilización).
  \end{enumerate}
\item En general, este método sólo se utiliza para definir algunos eventos 
y en algunos otros casos especiales (se verá más adelante).
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Primer Script}
\begin{itemize}
\small
\item Este primer script de ejemplo se incluye como un bloque de código 
dentro de una página XHTML: 
 \begin{lstlisting}[style=JavaScriptTiny]
  <html xmlns="http://www.w3.org/1999/xhtml">
    <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>El primer script</title>
    <script type="text/javascript">
      alert("Hola Mundo!");
    </script>
    </head>
    <body>
    <p>Esta pagina contiene el primer script</p>
    </body>
  </html>
 \end{lstlisting}
 \item El script es tan sencillo que solamente incluye una sentencia: 
 \begin{lstlisting}[style=JavaScript]
 alert("Hola Mundo!");
 \end{lstlisting}
 \item La instrucción \textbf{alert()} permite mostrar un mensaje en la pantalla 
 del usuario.
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Aprendiendo JS}
\begin{itemize}
\item Para poder desarrollar programas y utilidades con JavaScript, 
es necesario conocer sus elementos básicos. 
\item En las siguientes secciones se explican en detalle y comenzando desde cero 
los conocimientos básicos necesarios para comprender y utilizar Javascript.
\item Entre ellos, conceptos básicos como variables, operadores, 
estructuras de control y funciones.
\item Y aspectos más avanzados como objetos, herencia, arrays o expresiones regulares.
\end{itemize}
\end{frame}


\subsection{Variables}

\begin{frame}[fragile,allowframebreaks]\frametitle{Variables}
\begin{itemize}
\item Una variable es un elemento que se emplea para almacenar 
y hacer referencia a otro valor.
% \item Gracias a las variables es posible crear "programas genéricos", es decir, programas que funcionan siempre igual independientemente de los valores concretos utilizados.
\item Las variables en JavaScript se crean mediante la palabra 
reservada \textbf{var}, ejemplo:
  \begin{lstlisting}[style=JavaScriptTiny]
   var numero_1 = 3;
   var numero_2 = 1;
   var resultado = numero_1 + numero_2;
  \end{lstlisting}
 \item La palabra reservada \textbf{var} solamente se debe indicar al definir 
 por primera vez la variable o ''declarar una variable''.
 \item Después, cuando se utilizan las variables solamente es necesario indicar el nombre.
 \item Por ejemplo, lo siguiente sería un error:
 \begin{lstlisting}[style=JavaScriptTiny]
  var numero_1 = 3;
  var numero_2 = 1;
  var resultado = var numero_1 + var numero_2;
 \end{lstlisting}
 \item Si cuando se declara una variable se le asigna también un valor, 
 se dice que la variable ha sido ``inicializada''.
 \item En JavaScript no es obligatorio inicializar las variables
  \item Por tanto, el ejemplo anterior se puede rehacer de la siguiente manera:
  \begin{lstlisting}[style=JavaScriptTiny]
   var numero_1;
   var numero_2;
   numero_1 = 3;
   numero_2 = 1;
   var resultado = numero_1 + numero_2;
  \end{lstlisting}
\item En realialidad, en JavaSript \textbf{tampoco es necesario declarar las variables}.
\item Se pueden utilizar variables que no se han definido anteriormente.
\framebreak
\item El ejemplo anterior también es correcto así:
   \begin{lstlisting}[style=JavaScriptTiny]
    var numero_1 = 3;
    var numero_2 = 1;
    resultado = numero_1 + numero_2;
   \end{lstlisting}
\item La variable \textbf{resultado} no está declarada 
por lo que:
  \begin{itemize}
  \item JavaScript crea una variable global (más adelante se verán las diferencias 
  entre variables locales y globales).
  \item Y le asigna el valor correspondiente.
  \end{itemize}
\item De la misma forma, también sería correcto el siguiente código:
   \begin{lstlisting}[style=JavaScriptTiny]
    numero_1 = 3;
    numero_2 = 1;
    resultado = numero_1 + numero_2;
   \end{lstlisting}
\item En cualquier caso, se recomienda declarar 
todas las variables que se vayan a utilizar.
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Nombres de Variables}
\begin{itemize}
 \item El nombre de una variable también se conoce como \textbf{identificador} y debe cumplir las siguientes normas:
    \begin{enumerate}
     \item Sólo puede estar formado por letras, números y los símbolos \textbf{\$}(Dólar) y \textbf{\_}(guión bajo).
     \item El primer carácter no puede ser un número.
    \end{enumerate}
 \item Las siguientes variables tienen nombres correctos:
 \begin{lstlisting}[style=JavaScriptTiny]
 var $numero1;
 var _$letra;
 var $$$otroNumero;
 var $_a__$4;
 \end{lstlisting}
 \item Las siguientes variables tienen identificadores incorrectos:
 \begin{lstlisting}[style=JavaScriptTiny]
 var 1numero;       // Empieza por un numero
 var numero;1_123;  // Contiene un caracter ";"  
 \end{lstlisting}

\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Tipos de Variables}
\small
JavaScript divide los distintos tipos de variables en dos grupos: 
\textbf{tipos primitivos y objetos (tipos de referencia).}

\vspace{-0.2cm}
\begin{itemize}
\small
\item JavaScript define cinco tipos primitivos: 
\textit{undefined, null, boolean, number y string.}
\item Además se define el operador \textbf{typeof} 
para averiguar el tipo de una variable.
 
\textbf{Variables undefined:}
 \begin{itemize}
 \scriptsize
  \item El tipo undefined corresponde a las variables que han sido definidas 
  pero a las que aún no se les ha asignado un valor:
  \begin{lstlisting}[style=JavaScriptTiny]
  var variable1;
  typeof variable1;  // devuelve undefined
  \end{lstlisting}
  \end{itemize}

  \vspace{-0.2cm}
  \textbf{Variables null:}
  \begin{itemize} 
  \scriptsize
  \item null se puede asignar a una variable como una representación de \textit{ningún valor.}
  \item La variable asignada a null tiene un valor definido (null):
  \begin{lstlisting}[style=JavaScriptTiny]
  var nombreUsuario = null;
  \end{lstlisting}
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Variables Boolean}
\begin{itemize} 
\small
\item Un Boolean sólo puede almacenar el valor true ("verdadero") o el valor
false ("falso").
\begin{lstlisting}[style=JavaScriptTiny]
var variable1 = true;
var variable2 = false; 
\end{lstlisting}
\item Los valores \textbf{true} y \textbf{false} son valores especiales 
(no son palabras ni números ni ningún otro tipo de valor). 
\item Cuando es necesario convertir una variable numérica a una variable de tipo boolean, 
JavaScript aplica la siguiente conversión: 
  \begin{itemize}
  \item El número \textbf{0} se convierte en \textbf{false}
  y cualquier otro número \textbf{distinto de 0} se convierte en \textbf{true}.
  \end{itemize}
\item Por este motivo, en ocasiones se asocia el número \textbf{0} con el valor \textbf{false} y el número \textbf{1} con el valor \textbf{true.}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Variables Numéricas}
\begin{itemize}
\item En JavaScript únicamente existe un tipo de número.
\item Internamente, es representado como un dato de 64 bits en coma flotante, al igual el tipo de dato double en Java. 
\item A diferencia de otros lenguajes de programación, no existe una diferencia entre un número entero y otro decimal, por lo que 1 y 1.0 son el mismo valor. 
\item Esto es significativo ya que evitamos los problemas desbordamiento en tipos de dato pequeños, al no existir la necesidad de conocer el tipo de dato.
\item Si el número es entero, se indica su valor directamente.
 \begin{lstlisting}[style=JavaScript]
 var variable1 = 10;
 \end{lstlisting}

\framebreak
 \item Si el número es decimal, se debe utilizar el punto \textbf{(.)} para separar la parte entera de la decimal.
 \begin{lstlisting}[style=JavaScript]
  var variable2 = 3.14159265; 
 \end{lstlisting}
 \item Además del sistema numérico decimal, también se pueden indicar valores en el sistema octal (si se incluye un cero delante del número) y en sistema hexadecimal (si se incluye un cero y una x delante del número).
 \begin{lstlisting}[style=JavaScriptTiny]
  var variable1 = 10;
  var variable_octal = 034;
  var variable_hexadecimal = 0xA3;
 \end{lstlisting}
 \item JavaScript define tres valores especiales muy útiles cuando se trabaja con números. 
 \item Los valores \textbf{Infinity y –Infinity} se utilizan para representar números 
 demasiado grandes (positivos y negativos) para JavaScript.
 \framebreak
 \item Ejemplo de operaciones con infinitos:
 \begin{lstlisting}[style=JavaScriptTiny]
  var variable1 = 3, variable2 = 0;
  console.log(variable1/variable2);  // muestra Infinity
 \end{lstlisting}
 \item El otro valor especial definido por JavaScript es \textbf{NaN}, que es el acrónimo de "Not a Number".
 \item De esta forma, si se realizan operaciones matemáticas con variables no numéricas, el resultado será de tipo NaN.
 \item Para manejar los valores NaN, se utiliza la función relacionada \textbf{isNaN()}, que devuelve true si el parámetro que se le pasa no es un número:
 \begin{lstlisting}[style=JavaScriptTiny]
  var variable1 = 3;
  var variable2 = "hola";
  isNaN(variable1);  // false
  isNaN(variable2);  // true
  isNaN(variable1 + variable2);  // true 
 \end{lstlisting}
\end{itemize}
\end{frame} 
 
\begin{frame}[fragile,allowframebreaks]\frametitle{Strings}
\begin{itemize}
 \item Las variables de tipo cadena de texto (string) permiten almacenar cuaquier sucesión de caracteres, por lo que se utilizan ampliamente en la mayoría de aplicaciones JavaScript.
 \item Cada carácter de la cadena se encuentra en una posición a la que se puede acceder individualmente, siendo el primer carácter el de la posición 0.
 \item El valor de las cadenas de texto se indica encerrado entre comillas simples o dobles:
 \begin{lstlisting}[style=JavaScriptTiny]
 var variable1 = "hola";
 var variable2 = 'mundo';
 var variable3 = "hola mundo, esta es una frase mas larga"; 
 \end{lstlisting}
 \item Las cadenas de texto pueden almacenar cualquier carácter, aunque algunos no se pueden incluir directamente en la declaración de la variable.
 \item Si por ejemplo se incluye un ENTER para mostrar el resto de caracteres en la línea siguiente, se produce un error en la aplicación:
 \begin{lstlisting}[style=JavaScriptTiny]
 var variable = "hola mundo, esta es
                                     una frase mas larga"; 
 \end{lstlisting}
 \item La variable anterior no está correctamente definida y se producirá un error en la aplicación. 
 \item Por tanto, resulta evidente que algunos caracteres especiales no se pueden incluir directamente.
 \item De la misma forma, como las comillas (doble y simple) se utilizan para encerrar los contenidos, también se pueden producir errores:
 \begin{lstlisting}[style=JavaScriptTiny]
  var variable1 = "hola 'mundo'";
  var variable2 = 'hola "mundo"';
  var variable3 = "hola 'mundo', esta es una "frase" mas larga";
 \end{lstlisting}
 \item Si el contenido de texto tiene en su interior alguna comilla simple, se encierran los contenidos con comillas dobles (como en el caso de la variable1 anterior). 
 \item Si el contenido de texto tiene en su interior alguna comilla doble, se encierran sus contenidos con comillas simples (como en el caso de la variable2 anterior). 
 \item Sin embargo, en el caso de la variable3 su contenido tiene tanto comillas simples como comillas dobles, por lo que su declaración provocará un error.
 \item Para resolver estos problemas, JavaScript define un mecanismo para incluir de forma sencilla caracteres especiales (ENTER, Tabulador) y problemáticos (comillas). 
 \item Esta estrategia se denomina "mecanismo de escape", ya que se sustituyen los caracteres problemáticos por otros caracteres seguros que siempre empiezan con la barra \textbf{\textbackslash}:
 \item A continuación se muestra como sería la conversión que se debe utilizar:
 \begin{itemize}
   \item Una nueva línea: \textbf{\textbackslash n}
   \item Un tabulador: \textbf{\textbackslash t}
   \item Una comilla simple: \textbf{\textbackslash '}
   \item Una comilla doble: \textbf{\textbackslash "}
   \item Una barra inclinada: \textbf{\textbackslash \textbackslash}
  \end{itemize}
 \item Utilizando el mecanismo de escape, se pueden corregir los ejemplos anteriores:
 \begin{lstlisting}[style=JavaScriptTiny]
  var variable = "hola mundo, esta es \n una frase mas larga";
  var variable3 = "hola 'mundo', esta es una \"frase\" mas larga";
 \end{lstlisting}
\end{itemize}
\end{frame} 

\begin{frame}[fragile,allowframebreaks]\frametitle{Conversión entre Tipos}
\begin{itemize} 
\item JavaScript es un lenguaje de programación ``no tipado``:
  \begin{itemize} 
  \item Una misma variable puede guardar diferentes 
  tipos de datos a lo largo de la ejecución de la aplicación.
  \item De esta forma, una variable se podría inicializar con un valor numérico,
  después podría almacenar una cadena de texto
  y podría acabar la ejecución del programa en forma de variable booleana.
  \end{itemize}
\item No obstante, en ocasiones es necesario que una variable almacene 
un dato de un determinado tipo. 
\item Para asegurar que así sea, se puede convertir una variable de un tipo a otro,
lo que se denomina \textbf{typecasting}.
\end{itemize}
\framebreak
\begin{itemize}
\small
\item Así, JavaScript incluye un método llamado \textbf{toString()} 
que permite convertir variables de cualquier tipo a variables tipo cadena de texto.
\item Ejemplo:
  \begin{lstlisting}[style=JavaScriptTiny]
  var variable1 = true;
  variable1.toString();  // devuelve "true" como cadena de texto
  var variable2 = 5;
  variable2.toString();  // devuelve "5" como cadena de texto 
  \end{lstlisting}
\item JavaScript también incluye métodos para convertir los valores 
de las variables en valores numéricos.
\item Los métodos definidos son \textbf{parseInt() y parseFloat()}, 
que convierten la variable que se le indica en un número entero o un número decimal respectivamente.
\item La conversión numérica de una cadena se realiza carácter a carácter empezando 
por el de la primera posición. 
\item Si el primer carácter no es un número, la función devuelve 
el valor NaN (Not a Number). 
\item Si el primer carácter es un número, se continúa con los siguientes caracteres 
mientras estos sean números.
\item Ejemplos:
 \begin{lstlisting}[style=JavaScriptTiny]
  var variable2 = "34";
  parseInt(variable2);  // devuelve 34
  var variable1 = "hola";
  parseInt(variable1);  // devuelve NaN
  var variable3 = "34hola23";
  parseInt(variable3);  // devuelve 34
  var variable4 = "34.23";
  parseInt(variable4);  // devuelve 34 
 \end{lstlisting}
\item En el caso de \textbf{parseFloat()}, el comportamiento es el mismo salvo que 
también se considera válido el carácter \textbf{.} que indica la parte decimal del número:
 \begin{lstlisting}[style=JavaScriptTiny]
  var variable1 = "hola";
  parseFloat(variable1);  // devuelve NaN
  var variable2 = "34";
  parseFloat(variable2);  // devuelve 34.0
  var variable3 = "34hola23";
  parseFloat(variable3);  // devuelve 34.0
  var variable4 = "34.23";
  parseFloat(variable4);  // devuelve 34.23 
 \end{lstlisting}
\end{itemize}
\end{frame} 

\begin{frame}[fragile]\frametitle{Objetos (Tipos de Referencia)}
\begin{itemize} 
\item Los objetos en JavaScript se crean mediante la palabra 
reservada \textbf{new} y el nombre del prototipo que se va a instanciar.
\item JavaScript no define el concepto de clase como en otros lenguajes OO 
(Orientados a Objetos).
\item En lugar de esto, JavaScript utiliza el concepto de ''prototipo`` 
(que se verá más adelante).
\item Por ejemplo, para crear un objeto de tipo \textbf{String} se indica lo siguiente:
\begin{lstlisting}[style=JavaScriptTiny]
var variable1 = new String("hola mundo"); 
\end{lstlisting}
\item Los paréntesis solamente son obligatorios cuando se utilizan argumentos, 
aunque se recomienda incluirlos incluso cuando no se utilicen.
\item JavaScript también define un prototipo para cada 
uno de los tipos de datos primitivos. 
\end{itemize}
\end{frame} 

\begin{frame}[fragile,allowframebreaks]\frametitle{\large Objetos Boolean, Number y String}
\begin{itemize} 
\small
\item Existen objetos de \textbf{tipo Boolean} 
para las variables booleanas,
\textbf{Number} para las variables numéricas 
y \textbf{String} para las variables de cadenas de texto.
\item Estos objetos almacenan los mismos valores de los tipos de datos primitivos 
pero añaden propiedades y métodos.
\item Ejemplo
\begin{lstlisting}[style=JavaScriptTiny]
var longitud = "hola mundo".length;
\end{lstlisting}
\item Nota sobre el prototipo String:
  \begin{itemize} 
  \footnotesize
  \item La propiedad \textbf{length} sólo está disponible en el prototipo String.
  \item Por este movito, en principio no debería poder utilizarse 
  en un dato primitivo de tipo cadena de texto.
  \item Sin embargo, JavaScript convierte el tipo de dato primitivo 
  al tipo de referencia String, obtiene el valor de la propiedad length 
  y devuelve el resultado. 
  \item Este proceso se realiza de forma automática y transparente para el programador.
  \end{itemize}
\end{itemize}

\framebreak
\begin{itemize}
\small
\item Nota sobre el prototipo String (cont):
  \begin{itemize}
  \footnotesize
  \item En realidad, con una variable de tipo String no se pueden 
  hacer muchas más cosas que con su correspondiente tipo de dato primitivo.
  \item Por este motivo, no existen muchas diferencias prácticas 
  entre utilizar el tipo de referencia o el tipo primitivo.
  \item Salvo en el caso del resultado del operador \textbf{typeof} y 
  en el caso de la función \textbf{eval()}, como se verá más adelante.
  \end{itemize}

\item Valor vs. referencia:
  \begin{itemize}
  \footnotesize 
  \item La principal diferencia entre los tipos de datos es que los datos primitivos 
  se manipulan por valor y los tipos de referencia se manipulan por referencia.
  \item Los conceptos "por valor" y "por referencia" son iguales al resto de lenguajes 
  de programación (ejemplo C).
  \item Aunque Javascript tiene particularidades como por ejemplo que 
  no existe el concepto de puntero.
  \end{itemize}
\end{itemize}
\end{frame} 

\begin{frame}[fragile,allowframebreaks]\frametitle{Variables por Valor}
\begin{itemize} 
\item Cuando un dato se manipula por valor, lo único que importa es el valor en sí. 
\item Cuando se asigna una variable por valor a otra variable, se copia directamente el valor de la primera variable en la segunda. 
\item Cualquier modificación que se realice en la segunda variable es independiente de la primera variable.
\item De la misma forma, cuando se pasa una variable por valor a una función (como se explicará más adelante) sólo se pasa una copia del valor. 
\item Así, cualquier modificación que realice la función sobre el valor pasado no se refleja en el valor de la variable original.
\framebreak
\item En el siguiente ejemplo, una variable se asigna por valor a otra variable:
\begin{lstlisting}[style=JavaScriptTiny]
var variable1 = 3;
var variable2 = variable1;
variable2 = variable2 + 5;
// Ahora variable2 = 8 y variable1 sigue valiendo 3
\end{lstlisting}
\item La variable1 se asigna por valor en la variable2.
\item Aunque las dos variables almacenan en ese momento el mismo valor, son independientes y cualquier cambio en una de ellas no afecta a la otra.
\item El motivo es que los tipos de datos primitivos siempre se asignan (y se pasan) por valor.
\end{itemize}
\end{frame} 

\begin{frame}[fragile]\frametitle{Variables por Referencia}

\begin{lstlisting}[style=JavaScriptTiny]
// variable1 = 25 diciembre de 2009
var variable1 = new Date(2009, 11, 25);
// variable2 = 25 diciembre de 2009
var variable2 = variable1;

// variable2 = 31 diciembre de 2010
variable2.setFullYear(2010, 11, 31);
// Ahora variable1 tambien es 31 diciembre de 2010 
\end{lstlisting}

\footnotesize
En el ejemplo anterior, se utiliza un tipo de dato de referencia 
denominado Date y que se utiliza para manejar fechas:
  \begin{itemize}
  \scriptsize 
  \item Se crea una variable llamada variable1 y se inicializa la fecha 
  a 25 de diciembre de 2009. 
  \item Al constructor del objeto Date se le pasa el año, 
  el número del mes (siendo 0 = enero, 1 = febrero, ..., 11 = diciembre) y 
  el día (al contrario que el mes, los días no empiezan en 0 sino en 1). 
  \item A continuación, se asigna el valor de la variable1 a otra variable llamada variable2.
  \item Como Date es un tipo de referencia, la asignación se realiza por referencia.
  \item Por lo tanto, las dos variables quedan "unidas" y hacen referencia al mismo objeto, al mismo dato de tipo Date. 
  \item De esta forma, si se modifica el valor de variable2 (y se cambia su fecha a 31 de diciembre de 2010) el valor de variable1 se verá automáticamente modificado.
  \end{itemize}
\end{frame} 

\subsection{Operadores}

\begin{frame}\frametitle{Operadores}
\begin{itemize}
 \item Hasta ahora, sólo se ha visto cómo crear variables de diferentes tipos y cómo mostrar su valor mediante la función \textbf{alert()}.
 \item Para hacer programas realmente útiles, son necesarias otro tipo de herramientas.
 \item Los operadores permiten manipular el valor de las variables, realizar operaciones matemáticas con sus valores y comparar diferentes variables.
 \item De esta forma, los operadores permiten a los programas realizar cálculos complejos y tomar decisiones lógicas en función de comparaciones y otros tipos de condiciones.
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Operador Asignación}
\begin{itemize}
\small
\item El operador de asignación se utiliza para guardar un valor específico 
en una variable.
\item El símbolo utilizado es =:
\begin{lstlisting}[style=JavaScriptTiny]
var numero1 = 3;
\end{lstlisting}
\item A la izquierda del operador, siempre debe indicarse el nombre de una variable. 
\item A la derecha del operador, se pueden indicar variables, valores, 
condiciones lógicas, etc. Ejemplos:
\begin{lstlisting}[style=JavaScriptTiny]
var numero1 = 3;
var numero2 = 4;

/* Error, la asignacion siempre se realiza a una variable,
por lo que en la izquierda no se puede indicar un numero */
5 = numero1;

// Ahora, la variable numero1 vale 5
numero1 = 5;

// Ahora, la variable numero1 vale 4
numero1 = numero2;
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Operadores Aritméticos}
\begin{itemize}
\small
\item JavaScript permite realizar manipulaciones matemáticas sobre el valor 
de las variables numéricas.
\item Los operadores definidos son: \textit{suma (+), resta (-), multiplicación (*), división (/)} y módulo (\%). Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var numero1 = 10;
var numero2 = 5;
resultado = numero1 / numero2;        // resultado = 2
resultado = numero1 + numero2;        // resultado = 15
resultado = numero1 - numero2;        // resultado = 5
resultado = numero1 * numero2;        // resultado = 50
resultado = numero1 % numero2;        // resultado = 0
numero1 = 9;
numero2 = 5;
resultado = numero1 % numero2;         // resultado = 4
\end{lstlisting}
\item También se pueden se pueden combinar con el operador asignación:
\begin{lstlisting}[style=JavaScriptTiny]
var numero1 = 5;
numero1 += 3;  // numero1 = numero1 + 3 = 8
numero1 -= 1;  // numero1 = numero1 - 1 = 4
numero1 *= 2;   // numero1 = numero1 * 2 = 10
numero1 /= 5;   // numero1 = numero1 / 5 = 1
numero1 %= 4;   // numero1 = numero1 % 4 = 1
\end{lstlisting}
\end{itemize}

\framebreak
\begin{itemize}
\small
\item Existen dos operadores especiales que solamente son válidos para las variables numéricas y se utilizan para incrementar o decrementar en una unidad el valor de una variable.
\begin{lstlisting}[style=JavaScriptTiny]
var numero = 5;
++numero;
alert(numero);  // numero = 6
\end{lstlisting}
\item El operador de incremento se indica mediante el prefijo \textbf{++} en el nombre de la variable.
\item El resultado es que el valor de esa variable se incrementa en una unidad. 
\item Por tanto, el anterior ejemplo es equivalente a:
\begin{lstlisting}[style=JavaScriptTiny]
var numero = 5;
numero = numero + 1;
alert(numero);  // numero = 6
\end{lstlisting}
\item De forma equivalente, el operador decremento (indicado como un prefijo \textbf{- -} en el nombre de la variable).
\item Se utiliza para decrementar el valor de la variable:
\begin{lstlisting}[style=JavaScriptTiny]
var numero = 5;
--numero;
alert(numero);  // numero = 4
\end{lstlisting}
\item El anterior ejemplo es equivalente a:
\begin{lstlisting}[style=JavaScriptTiny]
var numero = 5;
numero = numero - 1;
console.log(numero);  // numero = 4
\end{lstlisting}

\item Los operadores de incremento y decremento no solamente se pueden indicar como prefijo del nombre de la variable, sino que también es posible utilizarlos como sufijo:
\begin{lstlisting}[style=JavaScriptTiny]
var numero = 5;
numero++;
alert(numero);  // numero = 6
\end{lstlisting}
\item El resultado de ejecutar el script anterior es el mismo que cuando se utiliza el operador ++numero.

\framebreak
\item El siguiente ejemplo muestra las diferencias entre un  
pre-incremento o un post-incremento:
\begin{lstlisting}[style=JavaScriptTiny]
//ejemplo 1
var numero1 = 5;
var numero2 = 2;
numero3 = numero1++ + numero2;
// numero3 = 7, numero1 = 6
//ejemplo 2
var numero1 = 5;
var numero2 = 2;
numero3 = ++numero1 + numero2;
// numero3 = 8, numero1 = 6
\end{lstlisting}
\item Si el operador ++ se indica como prefijo del identificador de la variable 
(pre-incremento), su valor se incrementa antes de realizar cualquier otra operación. 
\item Si el operador ++ se indica como sufijo del identificador de la variable
(post-incremento), su valor se incrementa después de ejecutar la sentencia 
en la que aparece.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Operadores Lógicos}
\begin{itemize}
\item Los operadores lógicos son imprescindibles para realizar aplicaciones complejas.
\item Se utilizan para tomar decisiones sobre las instrucciones que debería 
ejecutar el programa en función de ciertas condiciones.
\item El resultado de cualquier operación que utilice operadores lógicos 
siempre es un valor lógico o \textit{boolean}. 
\end{itemize}
\framebreak

\begin{enumerate}
\item \textbf{\textit{Negación:}} 
  \begin{itemize}
  \footnotesize
  \item La negación lógica se obtiene prefijando el símbolo \textbf{!} al identificador de la variable. 
  \item Se utiliza para obtener el valor contrario al valor de la variable:
  \begin{lstlisting}[style=JavaScriptTiny]
  var visible = true;
  alert(!visible);  // Muestra "false" 
  \end{lstlisting}
  \item Si la variable contiene un número, se transforma en \textit{false} si vale 0 
  y en \textit{true} para cualquier otro número (positivo o negativo, decimal o entero).
  \item Si la variable contiene una cadena de texto, se transforma en \textit{false} si la cadena es vacía ("") 
  y en \textit{true} en otro caso.
  \item Ejemplos:
  \begin{lstlisting}[style=JavaScriptTiny]
  var cantidad = 0;
  vacio = !cantidad;  // vacio = true

  cantidad = 2;
  vacio = !cantidad;  // vacio = false

  var mensaje = "";
  mensajeVacio = !mensaje;  // mensajeVacio = true

  mensaje = "Bienvenido";
  mensajeVacio = !mensaje;  // mensajeVacio = false 
  \end{lstlisting}
  \end{itemize}

\framebreak
\item \textbf{\textit{AND:}} 
  \begin{itemize}
  \item La operación lógica AND obtiene su resultado combinando dos valores booleanos.
  \item El operador se indica mediante el símbolo \textbf{\&\&} y su resultado solamente es true si los dos operandos son true:
  \begin{lstlisting}[style=JavaScriptTiny]
  var valor1 = true;
  var valor2 = false;
  resultado = valor1 && valor2; // resultado = false

  valor1 = true;
  valor2 = true;
  resultado = valor1 && valor2; // resultado = true
  \end{lstlisting}
\end{itemize}
\framebreak

\item \textbf{\textit{OR:}} 
\begin{itemize}
\item La operación lógica OR también combina dos valores booleanos. 
\item El operador se indica mediante el símbolo \textbf{||} y su resultado es true si alguno de los dos operandos es true:
\begin{lstlisting}[style=JavaScriptTiny]
var valor1 = true;
var valor2 = false;
resultado = valor1 || valor2; // resultado = true

valor1 = false;
valor2 = false;
resultado = valor1 || valor2; // resultado = false
\end{lstlisting}
\end{itemize}
\end{enumerate}
\end{frame}
 
\begin{frame}[fragile,allowframebreaks]\frametitle{Operadores Relacionales}
 \begin{itemize} 
  \item Los operadores relacionales definidos por JavaScript son idénticos 
  a los que definen las matemáticas:
  \begin{itemize}
   \item  mayor que (>), menor que (<), mayor o igual (>=), menor o igual (<=), igual que (==) y distinto de (!=).
  \end{itemize}
  \item El resultado de todos estos operadores siempre es un valor booleano. Ejemplos:
  \begin{lstlisting}[style=JavaScriptTiny]
  var numero1 = 3;
  var numero2 = 5;
  resultado = numero1 > numero2; // resultado = false
  resultado = numero1 < numero2; // resultado = true
  numero1 = 5;
  numero2 = 5;
  resultado = numero1 >= numero2; // resultado = true
  resultado = numero1 <= numero2; // resultado = true
  resultado = numero1 == numero2; // resultado = true
  resultado = numero1 != numero2; // resultado = false
  \end{lstlisting}
  \framebreak
  \item Se debe tener especial cuidado con el operador de igualdad (==).
  \item El operador \textbf{==} se utiliza para comparar el valor de dos variables, por lo que es muy diferente del operador \textbf{=}, que se utiliza para asignar un valor a una variable:
  \begin{lstlisting}[style=JavaScriptTiny]
  // El operador "=" asigna valores
  var numero1 = 5;
  resultado = numero1 = 3;  //numero1 = 3 y resultado = 3
  // El operador "==" compara variables
  var numero1 = 5;
  resultado = numero1 == 3; //numero1 = 5 y resultado = false
  \end{lstlisting}
  \item Los operadores relacionales también se pueden utilizar con variables de tipo cadena de texto.
\end{itemize}
\end{frame}
 
 \begin{frame}[fragile,allowframebreaks]\frametitle{Operador typeof}
 \begin{itemize} 
  \item El operador \textbf{typeof} se emplea para determinar el tipo de dato 
  que almacena una variable.
  \item Su uso es muy sencillo, ya que sólo es necesario indicar el nombre de la 
  variable cuyo tipo se quiere averiguar:
  \begin{lstlisting}[style=JavaScriptTiny]
  var myFunction = function() {
    console.log('hola');
  };
  
  var myObject = {
      foo : 'bar'
  };
  
  var myArray = [ 'a', 'b', 'c' ];
  
  var myString = 'hola';
  
  var myNumber = 3;
  
  typeof myFunction;   // devuelve 'function'
  typeof myObject;     // devuelve 'object'
  typeof myArray;      // devuelve 'object' -- tenga cuidado
  typeof myString;     // devuelve 'string'
  typeof myNumber;     // devuelve 'number'
  
  typeof null;         // devuelve 'object' -- tenga cuidado
  
  if (myArray.push && myArray.slice && myArray.join) {
      // probablemente sea un vector
      // (este estilo es llamado, en ingles, "duck typing")
  }
  
  if (Object.prototype.toString.call(myArray) === '[object Array]') {
      // definitivamente es un vector;
      // esta es considerada la forma mas robusta
      // de determinar si un valor es un vector.
  }
  \end{lstlisting}
  \item Los posibles valores de retorno del operador son: undefined, boolean, number, string para cada uno de los tipos primitivos y object para los valores de referencia y también para los valores de tipo null.
  \item El operador typeof no distingue entre las variables declaradas pero no inicializadas y las variables que ni siquiera han sido declaradas.
 \end{itemize}
\end{frame}
 
 \begin{frame}[fragile]\frametitle{Operador instaceof}
 \begin{itemize}  
  \item El operador typeof no es suficiente para trabajar con tipos de referencia, ya que devuelve el valor object para cualquier objeto independientemente de su tipo.
  \item Por este motivo, JavaScript define el operador instanceof para determinar el
  prototipo concreto de un objeto.
  \begin{lstlisting}[style=JavaScriptTiny]
  var variable1 = new String("hola mundo");
  typeof variable1;             // devuelve "object"
  variable1 instanceof String;  // devuelve true
  \end{lstlisting}
  \item El operador \textbf{instanceof} sólo devuelve como valor true o false.
  \item De esta forma, instanceof no devuelve directamente el prototipo con el que
  se ha instanciado la variable, 
  sino que se debe comprobar cada posible prototipo individualmente.
\end{itemize}
\end{frame}

\subsection{Estructuras de control}

\begin{frame}[fragile]\frametitle{Estructuras de control}
\begin{itemize}
\item Los programas que se pueden realizar utilizando solamente variables y operadores son una simple sucesión lineal de instrucciones básicas. 
\item Las estructuras de control de flujo son instrucciones del tipo "si se cumple esta condición, hazlo; si no se cumple, haz esto otro". 
\item También existen instrucciones del tipo "repite esto mientras se cumpla esta condición".
\item De esta manera los programas dejan de ser una sucesión lineal de instrucciones para convertirse en programas inteligentes que pueden tomar decisiones en función del valor de las variables.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Estructura if... else}
\begin{itemize}
\small
\item La estructura if es la más utilizada en JavaScript (y en la mayoría de lenguajes). 
\item Se emplea para tomar decisiones en función de una condición.
\item Su definición formal es:
\begin{lstlisting}[style=JavaScriptTiny]
if(condicion) {
... 
}
\end{lstlisting}
\item Si la condición se cumple (es decir, si su valor es true) se ejecutan 
todas las instrucciones que se encuentran dentro de \{...\}.
\item Si la condición no se cumple (es decir, si su valor es false) 
no se ejecuta ninguna instrucción contenida en \{...\} 
y el programa continúa ejecutando el resto de instrucciones del script. 
\framebreak
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var showMsg = true;
if(showMsg) {
alert("Hola Mundo");
}
\end{lstlisting}
\item En el ejemplo anterior, el mensaje sí que se muestra al usuario ya 
que la variable showMsg tiene un valor de true y por tanto, 
el programa entra dentro del bloque de instrucciones del if.
\item El ejemplo se podría reescribir también como:
\begin{lstlisting}[style=JavaScriptTiny]
var showMsg = true;

if(showMsg == true) {
console.log("Hola Mundo");
} 
\end{lstlisting}
\item En este caso, la condición es una comparación entre el valor de la variable showMsg 
y el valor true.
\framebreak
\item Confundir los operadores == y = suele ser el origen de muchos errores de programación:
las comparaciones siempre se realizan con == ya que el operador = asigna valores. Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var mostrarMensaje = true;

// Se comparan los dos valores
if(mostrarMensaje == false) {
...
}

// Error - Se asigna el valor "false" a la variable
if(mostrarMensaje = false) {
...
} 
\end{lstlisting}
\item La condición que controla el if() puede combinar los diferentes operadores lógicos y relacionales mostrados anteriormente:
\begin{lstlisting}[style=JavaScriptTiny]
var mostrado = false; 
if(!mostrado) {
alert("Es la primera vez que se muestra el mensaje");
}
\end{lstlisting}
\item Los operadores AND y OR permiten encadenar varias condiciones simples para construir condiciones complejas:
\begin{lstlisting}[style=JavaScriptTiny]
var mostrado = false;
var usuarioPermiteMensajes = true;

if(!mostrado && usuarioPermiteMensajes) {
alert("Es la primera vez que se muestra el mensaje");
}
\end{lstlisting}
\item La condición anterior está formada por una operación AND sobre dos variables. 
\item A su vez, a la primera variable se le aplica el operador de negación antes de realizar la operación AND.
\item De esta forma, como el valor de mostrado es false, el valor \textit{!mostrado} sería true.
\item Como la variable \textit{usuarioPermiteMensajes} vale true, el resultado de \textit{!mostrado} \&\& \textit{usuarioPermiteMensajes} sería igual a true \&\& true.
\item Por lo que el resultado final de la condición del \textit{if()} sería true y por tanto, se ejecutan las instrucciones que se encuentran dentro del bloque del \textit{if()}.
\item En ocasiones, las decisiones que se deben realizar no son del tipo "si se cumple la condición, hazlo; si no se cumple, no hagas nada".
\item Normalmente las condiciones suelen ser del tipo "si se cumple esta condición, hazlo; si no se cumple, haz esto otro".
\item Para este segundo tipo de decisiones, existe una variante de la estructura if llamada \textbf{if...else}. Su definición formal es la siguiente:
\begin{lstlisting}[style=JavaScriptTiny]
if(condicion) {
...
}
else {
...
} 
\end{lstlisting}
\item Si la condición se cumple (es decir, si su valor es true) se ejecutan todas las instrucciones que se encuentran dentro del if(){..}.
\item Si la condición no se cumple (es decir, si su valor es false) se ejecutan todas las instrucciones contenidas en else {..}. Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var edad = 18;
if(edad >= 18) {
alert("Eres mayor de edad");
}
else {
alert("Eres menor de edad");
}
\end{lstlisting}
\item Así mismo, podemos comparar variables de tipo cadenas de texto:
\begin{lstlisting}[style=JavaScriptTiny]
var nombre = "";
if(nombre == "") {
alert("Aun no nos has dicho tu nombre");
}
else {
alert("Hemos guardado tu nombre");
}
\end{lstlisting}
\item La estructura \textbf{if...else} se puede encadenar para realizar varias 
comprobaciones seguidas. 
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var edad = 18;
if(edad < 12) {
alert("Eres muy joven");
}
else if(edad < 19) {
alert("Eres un adolescente");
}
else if(edad < 35) {
alert("Sigues siendo joven");
}
else {
alert("Eres un adulto.");
} 
\end{lstlisting}
\item No es obligatorio que la combinación de estructuras \textbf{if...else} acabe con la instrucción else, ya que puede terminar con una instrucción de tipo \textbf{else if()}.
\end{itemize}
\end{frame}


\begin{frame}[fragile,allowframebreaks]\frametitle{Estructura switch}
\begin{itemize}
\small
\item La estructura switch es muy útil cuando la condición que evaluamos 
puede tomar muchos valores. 
\item Si utilizásemos una sentencia if...else, 
tendríamos que repetir la condición para los distintos valores.
 \begin{lstlisting}[style=JavaScriptTiny]
  if(dia == 1) {
    console.log("Hoy es lunes.");
  } else if(dia == 2) {
    console.log("Hoy es martes.");
  } else if(dia == 3) {
    console.log("Hoy es miercoles.");
  } else if(dia == 4) {
    console.log("Hoy es jueves.");
  } else if(dia == 5) {
    console.log("Hoy es viernes.");
  } else if(dia == 6) {
    console.log("Hoy es sabado.");
  } else if(dia == 0) {
    console.log("Hoy es domingo.");
  }
 \end{lstlisting}
\item En este caso es más conveniente utilizar una estructura de control de tipo switch, 
ya que permite ahorrarnos trabajo y producir un código más limpio.
\item Un ejemplo de uso es el siguiente:
  \begin{lstlisting}[style=JavaScriptTiny]
  switch(dia) {
  case 1: console.log("Hoy es lunes."); break;
  case 2: console.log("Hoy es martes."); break;
  case 3: console.log("Hoy es miercoles."); break;
  case 4: console.log("Hoy es jueves."); break;
  case 5: console.log("Hoy es viernes."); break;
  case 6: console.log("Hoy es sabado."); break;
  case 0: console.log("Hoy es domingo."); break;
  default: console.log("something"); break;
  }
  \end{lstlisting}
\item La estructura switch se define mediante la palabra reservada \textbf{switch} seguida,
entre paréntesis, del nombre de la variable que se va a utilizar en las comparaciones.
\item Como es habitual, las instrucciones que forman parte del switch se encierran 
entre las llaves: \{...\}
\item Dentro del switch se definen todas las comparaciones que se quieren realizar 
sobre el valor de la variable.
\item Cada comparación se indica mediante la palabra reservada \textbf{case} 
seguida del valor con el que se realiza la comparación. 
\item Si el valor de la variable utilizada por switch coincide con el valor 
indicado por case, se ejecutan las instrucciones definidas dentro de ese \textit{case}.
\item Normalmente, después de las instrucciones de cada case se incluye 
la sentencia \textbf{break} para terminar la ejecución del switch, 
aunque no es obligatorio. 
\item Las comparaciones se realizan por orden, desde el primer case hasta el último, 
por lo que es muy importante el orden en el que se definen los case.
\item Se utiliza el valor \textbf{default} para indicar las instrucciones que
se ejecutan en el caso en el que ningún case se cumpla para la variable indicada.
\item Aunque default es opcional, las estructuras switch suelen incluirlo para definir
al menos un valor por defecto para alguna variable o para mostrar algún mensaje 
por pantalla.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Estructura while}
\begin{itemize}
\small
\item La estructura \textbf{while} permite crear bucles que se ejecutan cero 
 o más veces, dependiendo de la condición indicada. 
 \item Su definición formal es:
 \begin{lstlisting}[style=JavaScriptTiny]
 while(condicion) {
 ...
 } 
 \end{lstlisting}
 \item La idea del funcionamiento del bucle while es la siguiente: 
 \begin{itemize}
 \scriptsize
 \item "Mientras la condición indicada se siga cumpliendo, repite la ejecución de las instrucciones definidas dentro del while".
 \item Si la condición no se cumple ni siquiera la primera vez, el bucle no se ejecuta.
 \item Si la condición se cumple, se ejecutan las instrucciones una vez y se vuelve a comprobar la condición. 
 \item Si se sigue cumpliendo la condición, se vuelve a ejecutar el bucle y así se continúa hasta que la condición no se cumpla.
 \end{itemize}
 \item Evidentemente, las variables que controlan la condición deben modificarse dentro del propio bucle, ya que de otra forma, la condición se cumpliría siempre y el bucle while se repetiría indefinidamente.
 \item El siguiente ejemplo utiliza el bucle while para sumar todos los números menores o iguales que otro número:
 \begin{lstlisting}[style=JavaScriptTiny]
 var resultado = 0;
 var numero = 100;
 var i = 0;
  
 while(i <= numero) {
   resultado += i;
   i++;
 }
  
 alert(resultado); 
 \end{lstlisting}
  \begin{itemize}
  \scriptsize
  \item Es decir, mientras que la variable i sea menor o igual que la variable numero, se ejecutan las instrucciones del bucle.
  \item Dentro del bucle se suma el valor de la variable i al resultado total (variable resultado) y se actualiza el valor de la variable i, que es la que controla la condición del bucle.
  \item Si no se actualiza el valor de la variable i, la ejecución del bucle continua infinitamente o hasta que el navegador permita al usuario detener el script.
  \end{itemize}
\end{itemize}
\end{frame}
 
\begin{frame}[fragile,allowframebreaks]\frametitle{Estructura for}
\begin{itemize} 
 \item La estructura \textbf{for} permite realizar repeticiones de un bloque de código de 
 forma sencilla (también llamado bucle). 
 \item Su definición formal es la siguiente:
 \begin{lstlisting}[style=JavaScriptTiny]
 for(inicializacion; condicion; actualizacion) {
 ...
 } 
 \end{lstlisting}

  \begin{itemize} 
  \footnotesize
  \item La \textbf{inicialización} es la zona en la que se establecen los valores iniciales 
  de las variables que controlan la repetición.
  \item La \textbf{condición} es el elemento (único) que decide si el bucle continua 
  o se detiene.
  \item La \textbf{actualización} es el nuevo valor que se asigna 
  a las variables que controlan la repetición después de cada repetición.
  \end{itemize}
 
\framebreak

\item La idea del funcionamiento de un bucle for es la siguiente:

\vspace{0.2cm}
\small{\textit{Mientras la condición indicada se siga cumpliendo, 
repite la ejecución de las instrucciones definidas dentro del for. 
Además, después de cada repetición, actualiza el valor de las variables 
que se utilizan en la condición.}}
 
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var dias = ["Lunes", "Martes", "Miercoles", "Jueves", "Viernes", "Sabado", "Domingo"];

for(var i=0; i<7; i++) {
alert(dias[i]);
} 
\end{lstlisting}
\item El ejemplo muestra los días de la semana contenidos en un vector o array. 
\item Nota. El uso del array en el ejemplo es auto-explicativo (posteriormente
se proporcionan más detalles sobre arrays).
\end{itemize}
\end{frame}
 
\begin{frame}[fragile,allowframebreaks]\frametitle{Estructura for...in}
\begin{itemize} 
\item Una estructura de control derivada de for es \textbf{for...in}. 
\item Esta estructura permite interaccionar con objetos Javascript iterativamente.
\item En particular, for...in permite recorrer las propiedades de un objeto.
\item En cada iteración, un nuevo nombre de propiedad del objeto es asignada 
a una variable de control del bucle.
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
for(propiedad in object) {
if (object.hasOwnProperty(propiedad)) {
  ...
}
} 
\end{lstlisting}
\item Suele ser conveniente comprobar que la propiedad pertenece efectivamente al objeto, 
a través de la función \textbf{object.hasOwnProperty(propiedad)}. 

\framebreak
\item Javascript también adapta esta estructura para los arrays.
\item La definición de la estructura adaptada a arrays es la siguiente:
\begin{lstlisting}[style=JavaScriptTiny]
for(indice in array) {
... 
}
\end{lstlisting}
\item Si se quieren recorrer todos los elementos que forman un array, 
la estructura for...in es la forma más eficiente de hacerlo.
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var dias = ["Lunes", "Martes", "Miercoles", "Jueves", "Viernes", "Sabado", "Domingo"];

for(i in dias) {
alert(dias[i]);
}
\end{lstlisting}
\item La variable que se indica como indice es la que se puede utilizar dentro del bucle for...in para acceder a los elementos del array.
\item De esta forma, en la primera repetición del bucle la variable i vale 0 y en la última vale 6.
\item Esta estructura de control es la más adecuada para recorrer arrays y objetos:
  \begin{itemize} 
  \item Evita tener que indicar la inicialización y las condiciones del bucle.
  \item Funciona correctamente cualquiera que sea la longitud del array/objeto.
  \item De hecho, sigue funcionando igual aunque varíe el número de elementos del array.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Estructura try...catch}
\begin{itemize} 
\small
\item La estructura \textbf{try... catch} controla las excepciones que 
se puedan producir en la ejecución de un bloque de código. 
\item Las excepciones son situaciones de error.
\item La definición formal de la estructura es la siguiente:
\begin{lstlisting}[style=JavaScriptTiny]
try {
funcion_que_no_existe();
} catch(ex) {
console.log("Error detectado: " + ex.description);
}
 \end{lstlisting}
\item En este ejemplo, llamamos a una función que no está definida y esto provoca una excepción. 
\item Este error o excepción es capturado por la cláusula \textbf{catch}. 
\item catch contiene una serie de sentencias que indican las acciones a realizar 
con esa excepción que acaba de producirse.
\item Si no se produce ninguna excepción en el bloque try, 
no se ejecuta el bloque dentro de catch.
\end{itemize}
\end{frame} 

\begin{frame}[fragile]\frametitle{Cláusula finally}
\begin{itemize} 
  \item La cláusula \textbf{finally} contiene las sentencias a ejecutar después 
  de los bloques try...catch.
  \item Las sentencias incluidas en este bloque se ejecutan siempre, 
  se haya producido una excepción o no. 
  \item Un uso clásico de la cláusula finally 
  es el de liberar recursos que el script ha solicitado.
  \item Ejemplo:
  \begin{lstlisting}[style=JavaScriptTiny]
   abrirFichero()
   try {
     escribirFichero(datos);
   } catch(ex) {
   // Tratar la excepcion
   } finally {
     cerrarFichero(); // siempre se cierra el recurso
   } 
  \end{lstlisting}
\end{itemize}
\end{frame}

\subsection{Funciones}

\begin{frame}[fragile,allowframebreaks]\frametitle{Funciones}
\begin{itemize}
\small
\item Las funciones son la base de la modularidad de cualquier lenguaje de programación.
\item Son utilizadas para reutilizar código, ocultar información y para la abstracción. 
\item \textbf{Llamar a una función} suspende la ejecución de la función actual, 
pasando el control y los parámetros a la nueva función. 
\item Las funciones en JavaScript se definen mediante la palabra reservada \textbf{function}, seguida del nombre de la función.
\item El nombre de la función se utiliza para llamar a esa función 
cuando sea necesario (igual que con las variables, a las que se les asigna 
un nombre único).
\item Después del nombre de la función, se incluyen dos paréntesis donde indicaremos los parámetros de la función. 
\item Por último, los símbolos \{ y \} se utilizan para encerrar todas las instrucciones que pertenecen a la función.

\framebreak
\item La definición formal es la siguiente:
\begin{lstlisting}[style=JavaScriptTiny]
function nombre_funcion() {
...
} 
\end{lstlisting}

\item Las funciones en Javascript \textbf{son objetos}.
\item Pueden ser utilizadas como cualquier otro objeto. 
\item Pueden ser almacenadas en variables, objetos o arrays.
\item Además, al ser objetos, también pueden tener métodos. 
\item Lo que las hace realmente especiales es que \textbf{pueden ser llamadas}.
\item Pueden ser pasadas como argumentos a otras funciones, 
y pueden ser retornadas por otras funciones.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Argumentos}
\begin{itemize}
\item Las funciones más sencillas no necesitan ninguna información 
para producir sus resultados.
\item Sin embargo, es muy habitual que las funciones utilicen información 
externa en forma de \textbf{argumentos}.
\item Antes de poder utilizar los argumentos, 
la función debe indicar cuántos argumentos necesita 
y cuál es el nombre de cada argumento. 
\item Entonces, cuando se llama a la función, 
se incluyen los valores (o expresiones) de los argumentos.
\item Cuando se define la función, los argumentos se indican 
dentro de los paréntesis que van detrás del nombre de la función.
\item Los diferentes argumentos van separados por comas:
\begin{lstlisting}[style=JavaScriptTiny]
var s = function sumShow(n1, n2) { ... } 
\end{lstlisting}
\item Entonces, para utilizar el valor de los argumentos dentro de la función, 
se debe emplear el mismo nombre con el que se definieron.
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var s = function sumShow(n1, n2) {
var resultado = n1 + n2;
console.log("El resultado es " + resultado);
} 
\end{lstlisting}
\item Dentro de la función, el valor de la variable n1 será igual al primer valor que se le pase a la función y el valor de la variable n2 será igual al segundo valor que se le pasa.
\item Las funciones no solamente puede recibir variables y datos, 
sino que también pueden devolver los valores que han calculado. 
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Retorno}
\begin{itemize}
\item Para devolver valores dentro de una función 
se utiliza la palabra reservada \textbf{return}.
\item Las funciones pueden devolver \textbf{un solo valor cada vez que se ejecutan}.
\item Aunque, el valor devuelto puede ser de cualquier tipo. 
\item Cuando la función llega a una instrucción de tipo \textbf{return}, 
se devuelve el valor indicado y finaliza la ejecución de la función. 
\item Por tanto, si hay instrucciones después de un return se ignoran 
(por eso return suele ser la última instrucción en la mayoría de funciones).
\item Para recoger el valor de vuelto por una función debe indicarse el nombre 
de una variable en el punto en el que se realiza la llamada.
\framebreak
\small
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var calcular_precio = function (precio) {
var impuestos = 1.21;
var gastosEnvio = 10;
var precioTotal = ( precio * impuestos ) + gastosEnvio;

return precioTotal;
} 
\end{lstlisting}
% \item Para que la función devuelva un valor, 
% solamente es necesario escribir la palabra reservada \textbf{return} 
% junto con el nombre de la variable que se quiere devolver.
\item En el ejemplo anterior, la ejecución de la función llega 
a la instrucción \texttt{return precioTotal;} 
\item En ese momento se devuelve el valor que contenga 
la variable \texttt{precioTotal}.
\item Para recoger el valor devuelto por la función en una variable 
denominada \texttt{precio\_calculado} debemos utilizar la siguiente sentencia:
\begin{lstlisting}[style=JavaScriptTiny]
var precio_calculado = calcular_precio(23.34);
\end{lstlisting}
\item Si no se indicara ninguna ninguna variable para recoger el resultado
JavaScript no muestra ningún error 
(el valor devuelto por la función simplemente se pierde).
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Arguments}
\begin{itemize}
\item Además de los argumentos declarados, todas las funciones en JavaScript 
reciben dos argumentos extra: 
  \begin{enumerate}
  \item \texttt{this}: sirve para referirse al objeto de la propia función 
  (lo veremos más adelante).
  \item \texttt{arguments}: es un pseudo-array cuyo funcionamiento se detalla 
  a continuación.
  \end{enumerate}
\item \texttt{arguments} da a la función acceso a todas los argumentos pasados 
en la llamada:
  \begin{itemize}
  \item Esto incluye argumentos extra que no coinciden con los parámetros 
  definidos en la función.
  \item Esto además hace posible escribir funciones que toman un número indefinido 
  de parámetros.
  \end{itemize}

\framebreak
\item Ejemplo de uso de \texttt{arguments}:
\begin{lstlisting}[style=JavaScriptTiny]
var sum = function() {
    var i, sum = 0;
    for (i = 0; i < arguments.length; i += 1) {
      sum += arguments[i];
    }
    return sum;
};
console.log("El resultado de la suma es" + sum(4, 8, 15, 16, 23, 42)); // 108 
\end{lstlisting}
\item Nota:
  \begin{itemize}
  \item Debido a un problema de diseño, \texttt{arguments} no es realmente un array.
  \item En realidad es un objeto que se comporta ''como un array``. 
  \item Dispone de la propiedad length, 
  pero no incluye el resto de métodos de los arrays.
  \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Funciones en Variables y Argumentos}
\begin{itemize}
\item En JavaScript, las funciones son objetos y como tales:
  \begin{itemize}
  \item Pueden ser asignadas a variables. 
  \item Pueden ser pasadas a otras funciones como argumentos.
  \end{itemize}
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
// Funcion que utiliza como parametro otra funcion:
var myFn = function(fn) {
  var result = fn();
  console.log(result);
};

// **Primera forma de llamar a myFn: 
myFn(function() { return 'hola mundo'; });  // muestra 'hola mundo'

// **Segunda forma de llamar a myFn:
var myOtherFn = function() {
    return 'hola mundo';
};
myFn(myOtherFn); // muestra 'hola mundo'
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Alcance}
\begin{itemize}
\item El alcance en un lenguaje de programación controla la visibilidad 
y el ciclo de vida de las variables y los parámetros. 
\item La mayoría de los lenguajes, con sintaxis de C, tienen un alcance de bloque
(sentencias definidas entre llaves).
\item Es decir, todas las variables definidas en un bloque no son visibles fuera de ese bloque. 
\item Desafortunadamente, JavaScript no tiene esa visibilidad de bloque, 
a pesar de que su sintaxis así pueda sugerirlo.
\item JavaScript tiene un alcance de función: 
  \begin{itemize}
  \item Los parámetros y variables definidos dentro de una función no son visibles 
  fuera de esa función.
  \item Una variable definida en cualquier lugar de la función, 
  es visible desde cualquier lugar dentro de esa función.
  \end{itemize}
\framebreak
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var foo = function () {
  var a = 3, b = 5;
  var bar = function () {
      var b = 7, c = 11;
      // En este punto, a es 3, b es 7, y c es 11

      a += b + c;
      // En este punto, a es 21, b es 7, y c es 11
  };

  // En este punto, a es 3, b es 5, y c es undefined

  bar();

  // En este punto, a es 21, b es 5
};
\end{lstlisting}
\item Nota. Si no se tiene en cuenta que el alcance en JavaScript es a nivel de nivel 
de función y no de bloque, esto puede ser una fuente de problemas.
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Callbacks}
\begin{itemize}
\small
\item Las funciones pueden facilitar el trabajo con métodos asíncronos. 
\item Supongamos el siguiente caso en el que hacemos una petición al servidor:
\begin{lstlisting}[style=JavaScriptTiny]
request = prepare_the_request();
response = send_request_synchronously(request);
display(response); 
\end{lstlisting}
\item El problema aquí, es que en la línea 2 esperamos la respuesta del servidor, 
por lo que bloqueamos la ejecución hasta obtener una respuesta.
\item Una estrategia mucho mejor es realizar una llamada asíncrona, proporcionando una función de respuesta (callback) que se ejecutará cuando la respuesta esté disponible:
\begin{lstlisting}[style=JavaScriptTiny]
request = prepare_the_request();
send_request_asynchronously(request, function (response) {
    display(response);
}); 
\end{lstlisting}
\end{itemize}
\end{frame}

\subsection{Objetos}

\begin{frame}[fragile]\frametitle{Objetos}
\begin{itemize}
\small
\item Excepto los tipos primitivos (\textit{undefined, null, boolean, number y string.})
el resto de elementos en JavaScript son objetos: funciones, arrays,
expresiones regulares, etc.
\item Un objeto en JavaScript es un contenedor de propiedades, 
donde una propiedad tiene un nombre y un valor. 
\item El nombre de una propiedad puede ser una cadena de caracteres,
incluso una vacía.
\item El valor de la propiedad puede ser cualquier valor que podamos utilizar
en JavaScript, excepto \textit{undefined.}
\item En JavaScript, los objetos son básicamente \textit{tablas hash}, 
esto es, un grupo de propiedades y funciones que pueden ser accedidos a través
de una clave.
\item Tanto las propiedades como los métodos (que no son más que propiedades 
cuyo valor es una función) pueden ser creados dinámicamente en tiempo de ejecución.
\end{itemize}
\end{frame}


\begin{frame}[fragile,allowframebreaks]\frametitle{Creación de Objetos}
\begin{itemize}
\item La manera más simple de construir un objeto es:
\begin{itemize}
\item Declarar una nueva variable de tipo \textbf{Object}.
\item Asignarle las propiedades o métodos que el objeto necesite.
\end{itemize}
\item Ejemplo:
\begin{lstlisting}[style=JavaScriptTiny]
var obj = new Object();
obj.foo = "bar";
obj.hello = function() { console.log("Hello world!"); }
\end{lstlisting}
\item Otra forma, denominada ''notación literal``, es crear el objeto utilizando 
una pareja de llaves \{ \}:
\begin{lstlisting}[style=JavaScriptTiny]
  var obj   = {};
  obj.foo   = "bar";
  obj.hello = function() { console.log("Hello world!"); }
 \end{lstlisting}

\item Se pueden definir las propiedades entre las llaves: 
 
\begin{lstlisting}[style=JavaScriptTiny] 
var obj = {
    "foo"   : "bar",
    "hello" : function() { console.log("Hello world!"); }
};
\end{lstlisting}
\framebreak
\small
\item Respecto al \textbf{nombre de una propiedad}: 
  \begin{itemize}
  \footnotesize
  \item Las comillas dobles alrededor del nombre de la propiedad 
  no son necesarias si el nombre es un nombre legal de JavaScript 
  (es decir, no es una palabra reservada). 
  \item El nombre de una propiedad es un string 
  (incluso puede ser un string vacío). 
  \end{itemize}
\item Respecto al \textbf{valor de una propiedad}, puede ser cualquier expresión, 
incluso la definición de otro objeto:
\begin{lstlisting}[style=JavaScriptTiny]
var flight = {
  airline: "Oceanic",
  number: 815,
  departure: {
      IATA: "SYD",
      time: "2004-09-22 14:55",
      city: "Sydney"
  },
  arrival: {
      IATA: "LAX",
      time: "2004-09-23 10:42",
      city: "Los Angeles"
  }
};
\end{lstlisting}
\end{itemize}
\end{frame}


\begin{frame}[fragile]\frametitle{Métodos}
\begin{itemize}
\small
\item En JavaScript, los objetos son dinámicos, 
esto quiere decir que sus propiedades no tienen por qué definirse
en el momento en el que creamos el objeto. 
\item Podemos añadir nuevas propiedades al objeto en tiempo de ejecución, 
tan solo indicando el nombre la propiedad y asignándole un valor o función.
\begin{lstlisting}[style=JavaScriptTiny]
var cat = new Object();
cat.name = "Rufus";
cat.species = "cat";
cat.hello = function() { console.log("miaow"); } 
\end{lstlisting}
\item En el ejemplo, el valor de la propiedad ''hello`` no es un tipo primitivo 
sino una función. 
\item Las propiedades que tienen como valor una función, 
son tratadas como métodos del objeto.
\item Notar que no es necesario definir la función previamente 
(se puede utilizar una función anónima para declarar el método).
\end{itemize}
\end{frame}


\begin{frame}[fragile,allowframebreaks]\frametitle{Usos de la Notación Literal}
\begin{itemize}
\small
\item Crear objetos utilizando la notación literal es muy útil en situaciones 
en las que queremos pasar una serie de datos relacionados 
a una función o configurar una librería externa.
\item Ejemplo:
  \begin{itemize}
  \footnotesize
  \item Imaginemos una situación en la que utilizamos una librería que nos permite crear una galería de imágenes.
  \item Una posible solución sería definir un método para cada una de las propiedades 
  de la galería, de manera que pudiésemos llamar a cada uno de esos métodos 
  con el valor correspondiente.
  \item Esto supondría tener dos métodos por cada propiedad (getter y setter), 
  así como una llamada para cada propiedad que deseemos configurar.
  \item Utilizando una notación literal de objetos, podemos ahorrarnos todo este código y configurar la librería utilizando un único objeto.
  \end{itemize}
\framebreak
\item Creación del objeto:

\begin{lstlisting}[style=JavaScriptTiny]
domElement.fancybox({
  maxWidth    : 800,
  maxHeight   : 600,
  fitToView   : false,
  width       : '70%',
  height      : '70%',
  autoSize    : false,
  closeClick  : false,
  openEffect  : 'none',
  closeEffect : 'none'
}); 
\end{lstlisting}
\item Otra de las ventajas que nos ofrece esta notación literal, 
es poder crear librerías de utilidades:

  \begin{itemize}
  \footnotesize
  \item Esto es equivalente a crear una clase abstracta con métodos estáticos 
  en otros lenguajes de programación como Java o C\#.
  \end{itemize}

\framebreak
\item A continuación se muestra un ejemplo de cómo fácilmente podríamos crear 
una librería de utilidades para arrays:

\begin{lstlisting}[style=JavaScriptTiny]
var ArrayUtil = {
  contains : function(array, element)
  {
      for(var x=0; x<array .length; x++)
      {
	  if(array[x] === element)
	      return true;
      }
      return false;
  },
  exclude : function(list, items)
  {
      ...
  },
  makeList : function(list)
  {
      ...
  }
}

var list = ["A", "B", "C"];
console.log("Contiene A? " + ArrayUtil.contains(list, "A")); 
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Acceso a Propiedades}
\begin{itemize}
\item En general, para acceder al valor de una propiedad de un objeto se 
indica el nombre de la propiedad dentro de corchetes [ ] 
(como si accediésemos a un elemento de un \textit{array}).
\item Si el nombre de la propiedad es un nombre legal en JavaScript 
(no palabra reservada) se puede utilizar la notación con punto para acceder al 
valor de las propiedades.
\item Ejemplos:
\begin{lstlisting}[style=JavaScriptTiny]
flight["airline"]       // "Oceanic"
flight.departure.IATA   // "SYD" 
\end{lstlisting}
\item En cualquier caso, si es posible, es preferible utilizar la notación
con punto ya que es más corta y comúnmente utilizada en otros
lenguajes orientados a objetos.
\item En algunas ocasiones, es interesante utilizar la notación con corchetes
que utiliza strings como claves:
  \begin{itemize}
  \item Esta notación nos permite construir un string en tiempo de ejecución y 
  utilizarlo para acceder a una determinada propiedad de un objeto.
  \item Por ejemplo, podemos crear un bucle para iterar sobre las propiedades 
  de un objeto:
  \end{itemize}
\begin{lstlisting}[style=JavaScriptTiny]
var myObject = {
    property1: "chocolate",
    property2: "cake",
    property3: "brownies"
}

for(var x=1; x<4; x++){
  console.log(myObject["property" + x]);
  } 

// Alternativamente:  
for(var property in myObject){
  console.log(cat[property].toString());
  }
\end{lstlisting}
\end{itemize}

\framebreak

\begin{itemize}
\small
\item Si se intenta acceder a una propiedad que no existe, JavaScript devuelve el 
valor ''undefined``:
\begin{lstlisting}[style=JavaScriptTiny]
var a = myObject.property4     // a contiene el valor undefined.
\end{lstlisting}
\item Asignar un valor si una propiedad no está definida:
\begin{lstlisting}[style=JavaScriptTiny]
var a = myObject["property4"] || "red";  
\end{lstlisting}
  \begin{itemize}
  \footnotesize
  \item El operador || asigna el valor \texttt{red} a la variable \texttt{a} si
  \texttt{myObject["property4"]} es un ''falsey``. 
  \item Un falsey es un valor false, null, undefined, 0 o "".
  \end{itemize}
\item Por otra parte, al acceder a una propiedad undefined:
  \begin{itemize}
  \footnotesize
  \item Se lanzará una excepción de tipo \textbf{TypeError}.
  \item En ese caso, el operador \&\& puede usarse para asegurarnos que
  la propiedad existe y es accesible:
  \end{itemize}
\begin{lstlisting}[style=JavaScriptTiny]
a = flight.equipment       // a es undefined
a = flight.equipment.model // TypeError: Cannot read  
                           // property 'model' of undefined
a = flight.equipment && flight.equipment.model  // undefined 
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Modificación}
\begin{itemize}
 \item El valor de una objeto puede actualizarse a través de una asignación. 
 \item Si el nombre de la propiedad existe en el objeto, su valor es reemplazado:
 \begin{lstlisting}[style=JavaScriptTiny]
 stooge['first-name'] = 'Arkaitz'; 
 \end{lstlisting}
 \item Si la propiedad no existe en el objeto, esta nueva propiedad es añadida al objeto:
  \begin{lstlisting}[style=JavaScriptTiny]
 stooge['middle-name'] = 'Lester';
 stooge.nickname = 'Curly';
 flight.equipment = { model: 'Boeing 777' }
 flight.status = 'overdue';
 \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Borrado}
\begin{itemize}
 \item El operador delete puede ser utilizado para eliminar la propiedad de un objeto.
 \item Este operador eliminará la propiedad de un objeto, si la tuviera, pero no afectará al resto de propiedades de los prototipos.
 \begin{lstlisting}[style=JavaScriptTiny]
 another_stooge.nickname // 'Moe'
 
 // Remove nickname from another_stooge, revealing
 // the nickname of the prototype.
 delete another_stooge.nickname;
 
 another_stooge.nickname // 'Curly' 
 \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Referencias}
\begin{itemize}
\item Los objetos siempre son accedidos como referencias.
\item Nunca se copia su valor cuando los asignamos a otros objetos o 
los pasamos como parámetros en funciones.
\item Ejemplos:
\begin{lstlisting}[style=JavaScriptTiny]
var x = y;
x.nickname = 'Curly';
var nick = y.nickname; // nick contiene 'Curly' porque x e y 
                       // referencian al mismo objeto

var a = {}, b = {}, c = {};  // a, b, y c hacen referencia a
                            // diferentes objetos vacios

a = b = c = {};   // a, b, y c hacen referencia al
                  // mismo objeto vacio
                  
var obj { value = 5 };
console.log(obj.value); // o.value = 5

function change(obj)
{
    obj.value = 6;
}
change(obj);
console.log(obj.value); // o.value = 6
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Enumeración de Propiedades}
\begin{itemize}
 \item La sentencia \textbf{for...in} puede iterar sobre todos los nombres de propiedades de un objeto.
 \item Esta iteración incluirá todas las propiedades, funciones y propiedades definidas en los prototipos, en las que no podemos estar interesados.
 \item La mejor manera de filtrar estas propiedades es a través 
 de la función \textbf{hasOwnProperty} y el operador \textbf{typeof}:
 \begin{lstlisting}[style=JavaScriptTiny]
  var name;
  for (name in myobj) {
      if (typeof myobj[name] !== 'function') {
	  console.log(name + ': ' + myobj[name]);
      }
  }
 \end{lstlisting}

\framebreak 
\item El problema del código anterior es que no hay garantía del orden 
en el que se van a mostrar las propiedades.
\item Si ese orden es importante, es mejor no utilizar for...in. 
\item En este caso, lo mejor es acceder directamente 
a las propiedades concretas en el orden que definamos:
\begin{lstlisting}[style=JavaScriptTiny]
var i;
var properties = [
    'first-name',
    'middle-name',
    'last-name',
    'profession'
];

for (i = 0; i < properties.length; i += 1) {
    console.log(properties[i] + ': ' +
	myobj[properties[i]]);
}
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Variables Globales}
\begin{itemize}
\item JavaScript permite crear variables globales de una manera muy sencilla.
\item El principal problema de las variables globales es que 
pueden causar fácilmente conflictos de nombres.
\item Sobretodo si nuestro código utilizan librerias, widgets u otras aplicaciones.
\item Una manera de solucionar esto es crear una única variable global con 
el nombre de nuestra aplicación.

\begin{lstlisting}[style=JavaScriptTiny]
var MYAPP = {}; 
\end{lstlisting}

\item En este caso, la variable global MYAPP va a incluir el resto de variables 
de nuestra aplicación.

\framebreak

\begin{lstlisting}[style=JavaScriptTiny]
MYAPP.stooge = {
  "first-name": "Joe",
  "last-name": "Howard"
};

MYAPP.flight = {
    airline: "Oceanic",
    number: 815,
    departure: {
	IATA: "SYD",
	time: "2004-09-22 14:55",
	city: "Sydney"
    },
    arrival: {
	IATA: "LAX",
	time: "2004-09-23 10:42",
	city: "Los Angeles"
    }
}; 
\end{lstlisting}
\item Con una sola variable global, además, nuestra aplicación puede leerse 
y entenderse de manera más sencilla.
\end{itemize}
\end{frame}


\subsection{Herencia}

\begin{frame}[fragile,allowframebreaks]\frametitle{Clases vs. Prototipos}
\begin{itemize}
\item Los lenguajes orientados a objetos basados en clases como Java o C++, 
se basan en \textbf{clases}:
  \begin{itemize}
  \item La clase es algo abstracto.
  \item Define todas las propiedades que caracteriza a una serie de objetos. 
  \item Por ejemplo, una clase Empleado, puede representar un conjunto de empleados.
  \end{itemize}
\item Y en \textbf{instancias}:
  \begin{itemize}
  \item Una instancia es la instanciación de una clase; es decir, uno de sus miembros. 
  \item Por ejemplo, Victoria podría ser una instancia de la clase Empleado, 
  representando a un individuo particular como un empleado.
  \item Una instancia tiene exactamente las propiedades de su clase padre (ni más, ni menos).
  \end{itemize}
\item Un lenguaje basado en prototipos, como JavaScript, no hace esta distinción: simplemente maneja objetos.
\item Este tipo de lenguajes tiene la noción de objetos prototipo, objetos usados como platilla para obtener las propiedades iniciales de un objeto. 
\item Cualquier objeto puede especificar su propias propieades, tanto en el momento que los creamos como en tiempo de ejecución. 
\item Además, cualquier objeto puede asociarse como prototipo a otro objeto, permitiendo compartir todas sus propiedades.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Definiendo una clase}
\begin{itemize}
 \item Un lenguaje basado en clases, definimos la clase de manera independiente. 
 \item En esta definición, especificamos los constructores, que son utilizamos para crear las instancias de las clases.
 \item Un método constructor, puede especificar los valores iniciales de una instancia de una clase, y realizar las operaciones necesarias a la hora de crear el objeto. 
 \item Utilizamos el operador \textbf{new}, conjuntamente con el nombre del constructor, para crear nuevas instancias.
 \item JavaScript sigue un modelo similar, pero no separa la definición de las propiedades del constructor.
 \item En este caso, definimos una función constructora para crear los objetos con un conjunto inicial de propiedades y valores.
 \item Cualquier función de JavaScript puede ser utilizada como constructor.
 \item Utilizamos el operador \textbf{new}, conjuntamente con el nombre de la función constructora, para crear nuevas instancias.
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Subclases y herencia}
\begin{itemize}
 \item En un lenguaje basado en clases, es posible crear estructura de clases a través de su definición. 
 \item En esta definición, podemos especificar que la nueva clase es una subclase de una clase que ya existe. 
 \item Esta subclase, hereda todas las propiedades de la superclase, y además puede añadir o modificar las propiedades heredadas.
 \item JavaScript implementa una herencia que nos permite asociar un objeto prototipo con una función constructora.
 \item De esta manera, el nuevo objeto hereda todas las propiedades del objeto prototipo.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Creando la herencia}
\begin{itemize}
 \item Veamos como se implementa esta herencia en JavaScript, a través de un simple ejemplo. 
 \item Queremos implementar la siguiente estructura:
 \begin{itemize}
  \item Un Empleado se define con las propiedades nombre (cuyo valor por defecto es una cadena vacía), y un departamento (cuyo valor por defecto es "General").
  \item Un Director está basado en Empleado. Añade la propiedad informes (cuyo valor por defecto es un array vacío).
  \item Un Trabajador está basado también en Empleado. Añade la propiedad proyectos (cuyo valor por defecto es un array vacío).
  \item Un Ingeniero está basado en Trabajador. Añade la propiedad maquina (cuyo valor por defecto es una cadena vacía) y sobreescribe la propiedad departamento con el valor "Ingeniería".
 \end{itemize}
 \item Codificación en JavaScript:
 \begin{lstlisting}[style=JavaScriptTiny]
  function Empleado (nombre, departamento) {
  this.nombre = nombre || "";
  this.departamento = departamento || "General";
  }
  
  function Director (nombre, departamento, informes) {
    this.base = Empleado;
    this.base(nombre, departamento);
    this.informes = informes || [];
  }
  Director.prototype = new Empleado;
  
  function Obrero (nombre, departamento, proyectos) {
    this.base = Empleado;
    this.base(nombre, departamento);
    this.proyectos = proyectos || [];
  }
  Obrero.prototype = new Empleado;
  
  function Ingeniero (nombre, proyectos, maquina) {
    this.base = Obrero;
    this.base(nombre, "Ingenieria", proyectos);
    this.maquina = maquina || "";
  }
  Ingeniero.prototype = new Obrero;
 \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}\frametitle{Prototipos}
\begin{itemize}
\item JavaScript en un lenguaje orientado a objetos \textbf{basado en prototipos}, 
en lugar de clases como son otros lenguajes OO.
\item Debido a esto, probablemete, es menos evidente entender cómo JavaScript 
nos permite crear herencia entre objetos.
\item En primer lugar, hay que comentar que \textbf{todos los objetos de JavaScript 
enlazan con un objeto prototipo del que heredan propiedades}. 
\item En general, cuando creamos un objeto nuevo, 
tenemos la posibilidad de seleccionar cuál será su prototipo. 
\item Los objetos creados a través de la notación literal 
están enlazados con \textit{Object.prototype} 
(un objeto estándar incluido en JavaScript).
\end{itemize}
\end{frame}


% % %FIXME JOSE Esto hay que arreglarlo
% % \begin{frame}[fragile]\frametitle{Funciones como Objetos}
% % \begin{itemize}
% % \item Las funciones en javascript son objetos enlazados con Function.prototype que a su vez enlaza con Object.prototype.
% % \item Estos objetos especiales a los que se enlazan las funciones incluyen dos propiedades 
% % ocultas: el contexto de la función y el código que implementa su comportamiento.
% % \item Toda función en JavaScript es creada con una propiedad \textbf{prototype.}
% % \item Su valor es un objeto con una propiedad \textbf{constructor} cuyo valor 
% % es la propia función. 
% % \item Nota. La propiedad prototype es diferente al enlace oculto 
% % a Function.prototype (que veremos más adelante).
% % 
% %  \item El parámetro \textbf{this} es muy importante en la programación orientada a objetos, y su valor viene determinado por el patrón de llamada utilizado. 
% %  \item Existen cuatro patrones de llamada en JavaScript: 
% %   \begin{itemize}
% %    \item El patrón de llamada method.
% %    \item El patrón de llamada function.
% %    \item El patrón de llamada constructor.
% %    \item El patrón de llamada apply.
% %   \end{itemize}

%  \item En frameworks como \textit{jQuery} por ejemplo, pasar funciones como argumentos es una práctica muy común.
% Habría que decir que es jQuery.
% % 
% % \end{itemize}
% % 
% % \end{frame}


\begin{frame}[fragile,allowframebreaks]\frametitle{Crear Objetos de Prototipos}
\begin{itemize}
\item El mecanismo general para crear objetos de prototipos que proporciona JavaScript
es complejo y seguramente desordenado.
\item Sin embargo, siguiendo unas ciertas pautas se puede simplificar 
de manera significativa. 
\item Para ilustrarlo, vamos a añadir un método de creación a nuestro objeto. 
\item El método create crea un nuevo \textbf{objeto} que utiliza un objeto antiguo como su prototipo.
 \begin{lstlisting}[style=JavaScriptTiny]
  // Shape - superclass
  function Shape() {
      this.x = 0;
      this.y = 0;
  }
  
  Shape.prototype.move = function(x, y) {
      this.x += x;
      this.y += y;
      console.info("Shape moved.");
  };
  
  // Rectangle - subclass
  function Rectangle() {
      Shape.call(this); //call super constructor.
  }
  
  Rectangle.prototype = Object.create(Shape.prototype);
  
  var rect = new Rectangle();
  
  rect instanceof Rectangle   // true.
  rect instanceof Shape       // true.
  
  rect.move(); // Outputs, "Shape moved."
 \end{lstlisting}
 \item Para los navegadores que no soportan la función create, podemos extender el objeto de JavaSript Object para incluir esta funcionalidad:
 \begin{lstlisting}[style=JavaScriptTiny]
  if (typeof Object.create !== 'function') {
      Object.create = function (o) {
	  var F = function () {};
	  F.prototype = o;
	  return new F();
      };
  }
  var another_stooge = Object.create(stooge); 
 \end{lstlisting}
 \item El prototipo enlazado no se ve afectado por las modificaciones. 
 \framebreak
 \item Si realizamos cambios en un objeto, el objeto prototipo no se ve afectado.
 \begin{lstlisting}[style=JavaScriptTiny]
  another_stooge['first-name'] = 'Harry';
  another_stooge['middle-name'] = 'Moses';
  another_stooge.nickname = 'Moe';
 \end{lstlisting}
 \item El enlace de los prototipos es únicamente utilizado cuando accedemos a los datos.
 \item Si intentamos acceder al valor de una propiedad, y esa propiedad no existe en el objeto, entonces JavaScript va a intentar obtener ese valor del prototipo del objeto. 
 \item Y si ese objeto tampoco dispone de la propiedad, lo intentará obtener de sucesivos prototipos, hasta que finalmente se encuentre con \textit{Object.prototype.}
 \framebreak
 \item Si la propiedad no existe en ninguno de los prototipos, entonces el valor devuelto es \textit{undefined.}
 \item La relación de prototipos es dinámica. 
 \item Si añadimos una nueva propiedad a un prototipo, entonces esta propiedad estará inmediatamente accesible para el resto de prototipos que estén basados en ese prototipo:
 \begin{lstlisting}[style=JavaScriptTiny]
  stooge.profession = 'actor';
  another_stooge.profession       // 'actor'
 \end{lstlisting}
\end{itemize}
\end{frame}




\subsection{Arrays}
\begin{frame}[fragile]\frametitle{Arrays}
\begin{itemize}
 \item Un array es una asignación lineal de memoria donde los elementos son accedidos a través de índices numéricos, siendo además una estructura de datos muy rápida. 
 \item Desafortunadamente, JavaScript no utiliza este tipo de arrays. 
 \item En su lugar, JavaScript ofrece un objeto que dispone de características que le hacen parecer un array. 
 \item Internamente, convierte los índices del array en \textit{strings} que son utilizados como nombres de propiedades, haciéndolo sensiblemente más lento que un array.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Representación de un Array}
\begin{itemize}
 \item JavaScript ofrecen una manera muy cómoda para crear y representar arrays.
 \item Una representación de un array consiste en una pareja de corchetes \textbf{([ ])} que contienen cero o más expresiones.
 \item El primer valor recibe la propiedad de nombre '0', la segunda la propiedad de nombre '1', y así sucesivamente. Se define de la siguiente manera:
 \begin{lstlisting}[style=JavaScriptTiny]
  var nombre_array = [valor1, valor2, ..., valorN];
 \end{lstlisting}
 \item Algunos ejemplos de declaración de arrays:
 \begin{lstlisting}[style=JavaScriptTiny]
  var empty = [];
 
  var numbers = [
      'zero', 'one', 'two', 'three', 'four',
      'five', 'six', 'seven', 'eight', 'nine'
  ];
  
  empty[1]        // undefined
  numbers[1]      // 'one'
  
  empty.length    // 0
  numbers.length  // 10 
 \end{lstlisting}
 \item Si representasemos el array como un objeto:
 \begin{lstlisting}[style=JavaScriptTiny]
  var numbers_object = {
    '0': 'zero', '1': 'one',    '2': 'two',
    '3': 'three', '4': 'four', '5': 'five',
    '6': 'six', '7': 'seven', '8': 'eight',
    '9': 'nine'
  ]; 
 \end{lstlisting}
 \item Se produce un efecto similar. Ambas representaciones contienen 10 propiedades, y estas propiedades tienen exactamente los mismos nombres y valores.
 \item La diferencia radica en que numbers hereda de \textit{Array.prototype}, mientras que numbers\_object lo hace de \textit{Object.prototype}, por lo que numbers hereda una serie de métodos que convierten a numbers en un array.
 \item En la mayoría de los lenguajes de programación, se requiere que todos los elementos de un array sean del mismo tipo, pero en JavaScript eso no ocurre.
 \item Un array puede contener una mezcla valores:
 \begin{lstlisting}[style=JavaScriptTiny]
  var misc = [
      'string', 98.6, true, false, null, undefined,
      ['nested', 'array'], {object: true}, NaN,
      Infinity
  ];
  misc.length // 10 
 \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Propiedad Length}
\begin{itemize}
 \item Todo array tiene una propiedad \textbf{length.}
 \item A diferencia de otros lenguajes, la longitud del array no es fija, y podemos añadir elementos de manera dinámica. 
 \item Esto hace que la propiedad length varíe, y tenga en cuenta los nuevos elementos. 
 \item La propiedad length hace referencia al mayor índice presente en el array, más uno. Esto es:
 \begin{lstlisting}[style=JavaScriptTiny]
  var myArray = [];
  myArray.length              // 0
  
  myArray[1000000] = true;
  myArray.length              // 1000001
  
  // myArray contiene un elemento!var myArray = [];
  myArray.length              // 0
  
  myArray[1000000] = true;
  myArray.length              // 1000001
  
  // myArray contiene un elemento! 
 \end{lstlisting}
 \item La propiedad length puede indicarse de manera explícita.
 \item Aumentando su valor, no vamos a reservar más espacio para el array, pero si disminuimos su valor, haciendo que sea menor que el número de elementos del array, eliminará los elementos cuyo índice sea mayor que el nuevo \textit{length:}
 \begin{lstlisting}[style=JavaScriptTiny]
  numbers.length = 3; // numbers es ['zero', 'one', 'two']
 \end{lstlisting}
\end{itemize}
\end{frame}
 
\begin{frame}[fragile]\frametitle{Borrado}
\begin{itemize}
 \item Como los arrays de JavaScript son realmente objetos, podemos utilizar el operador delete para eliminar elementos de un array:
 \begin{lstlisting}[style=JavaScriptTiny]
 delete numbers[2];
 // numbers es ['zero', 'one', undefined, 'shi', 'go']  , 2da posicion vale 'undefined'.
 \end{lstlisting}
 \item Desafortunadamente, esto deja un espacio en el array. 
 \item Esto es porque los elementos a la derecha del elemento eliminado conservan sus nombres. 
 \item Para este caso, JavaScript incorpora una función \textbf{splice}, que permite eliminar y reemplazar elementos de un array.
 \item El primer argumento indica el por qué elemento comenzar a reemplazar, y el segundo argumento el número de elementos a eliminar.
 \begin{lstlisting}[style=JavaScriptTiny]
 numbers.splice(2, 1);
 // numbers es ['zero', 'one', 'shi', 'go'] 
 \end{lstlisting}
\end{itemize}
\end{frame} 

\subsection{Utilidades}

\begin{frame}[fragile]\frametitle{Funciones y propiedades básicas}
\begin{itemize}
 \item JavaScript incorpora una serie de herramientas y utilidades para el manejo de las variables.
 \item De esta forma, muchas de las operaciones básicas con las variables, se pueden realizar directamente con las utilidades que ofrece JavaScript.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Funciones útiles para cadenas de textos}
\begin{itemize}
 \item A continuación se muestran algunas de las funciones más útiles para el manejo de cadenas de texto.
 \item \textit{length}, calcula la longitud de una cadena de texto (el número de caracteres que la forman):
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje = "Hola Mundo";
 var numeroLetras = mensaje.length; // numeroLetras = 10
 \end{lstlisting}
 \item \textit{+}, se emplea para concatenar varias cadenas de texto:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje1 = "Hola";
 var mensaje2 = " Mundo";
 var mensaje = mensaje1 + mensaje2; // mensaje = "Hola Mundo"  
 \end{lstlisting}
 \item Además del operador +, también se puede utilizar la función \textit{concat()}:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje1 = "Hola";
 var mensaje2 = mensaje1.concat(" Mundo"); // mensaje2 = "Hola Mundo"
 \end{lstlisting}
 \item Los espacios en blanco se pueden añadir al final o al principio de las cadenas y también se pueden indicar forma explícita:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje1 = "Hola";
 var mensaje2 = "Mundo";
 var mensaje = mensaje1 + " " + mensaje2; // mensaje = "Hola Mundo" 
 \end{lstlisting}
 \item \textit{toUpperCase()}, transforma todos los caracteres de la cadena a sus correspondientes caracteres en mayúsculas:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje1 = "Hola";
 var mensaje2 = mensaje1.toUpperCase(); // mensaje2 = "HOLA"    
 \end{lstlisting}
 \item \textit{toLowerCase()}, transforma todos los caracteres de la cadena a sus correspondientes caracteres en minúsculas:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje1 = "HolA";
 var mensaje2 = mensaje1.toLowerCase(); // mensaje2 = "hola"
 \end{lstlisting}
 \item \textit{charAt(posicion)}, obtiene el carácter que se encuentra en la posición indicada:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje = "Hola";
 var letra = mensaje.charAt(0); // letra = H
 letra = mensaje.charAt(2);     // letra = l
 \end{lstlisting}
 \item \textit{indexOf(caracter)}, calcula la posición en la que se encuentra el carácter indicado dentro de la cadena de texto, Si la cadena no contiene el carácter, la función devuelve el valor -1: 
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje = "Hola";
 var posicion = mensaje.indexOf('a'); // posicion = 3
 posicion = mensaje.indexOf('b');     // posicion = -1
 \end{lstlisting}
 \item \textit{lastIndexOf(caracter)}, calcula la última posición en la que se encuentra el carácter indicado dentro de la cadena de texto. Si la cadena no contiene el carácter, la función devuelve el valor -1:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje = "Hola";
 var posicion = mensaje.lastIndexOf('a'); // posicion = 3
 posicion = mensaje.lastIndexOf('b');     // posicion = -1
 //  La funcion lastIndexOf() comienza su busqueda desde el final de la cadena hacia el principio, aunque la posicion devuelta es la correcta empezando a contar desde el principio de la palabra.
 \end{lstlisting}
 \item \textit{substring(inicio, final)}, extrae una porción de una cadena de texto. El segundo parámetro es opcional. Si sólo se indica el parámetro inicio, la función devuelve la parte de la cadena original correspondiente desde esa posición hasta el final:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje = "Hola Mundo";
 var porcion = mensaje.substring(2); // porcion = "la Mundo"
 porcion = mensaje.substring(5);     // porcion = "Mundo"
 porcion = mensaje.substring(7);     // porcion = "ndo" 
 //Si se indica un inicio negativo, se devuelve la misma cadena original.
 \end{lstlisting}
 \item \textit{split(separador)}, convierte una cadena de texto en un array de cadenas de texto. La función parte la cadena de texto determinando sus trozos a partir del carácter separador indicado:
 \begin{lstlisting}[style=JavaScriptTiny]
 var mensaje = "Hola Mundo, soy una cadena de texto!";
 var palabras = mensaje.split(" ");
 // palabras = ["Hola", "Mundo,", "soy", "una", "cadena", "de", "texto!"];
 \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Funciones útiles para arrays}
\begin{itemize}
 \item A continuación se muestran algunas de las funciones más útiles para el manejo de arrays:
 \item \textit{length}, calcula el número de elementos de un array:
 \begin{lstlisting}[style=JavaScriptTiny]
 var vocales = ["a", "e", "i", "o", "u"];
 var numeroVocales = vocales.length; // numeroVocales = 5
 \end{lstlisting}
 \item \textit{concat()}, se emplea para concatenar los elementos de varios arrays:
 \begin{lstlisting}[style=JavaScriptTiny]
 var array1 = [1, 2, 3];
 array2 = array1.concat(4, 5, 6);   // array2 = [1, 2, 3, 4, 5, 6]
 array3 = array1.concat([4, 5, 6]); // array3 = [1, 2, 3, 4, 5, 6]
 \end{lstlisting}
 \item \textit{join(separador)}, es la función contraria a split(). Une todos los elementos de un array para formar una cadena de texto. Para unir los elementos se utiliza el carácter separador indicado:
 \begin{lstlisting}[style=JavaScriptTiny]
 var array = ["hola", "mundo"];
 var mensaje = array.join(""); // mensaje = "holamundo"
 mensaje = array.join(" ");    // mensaje = "hola mundo"
 \end{lstlisting}
 \item \textit{pop()}, elimina el último elemento del array y lo devuelve. El array original se modifica y su longitud disminuye en 1 elemento:
 \begin{lstlisting}[style=JavaScriptTiny]
 var array = [1, 2, 3];
 var ultimo = array.pop();
 // ahora array = [1, 2], ultimo = 3 
 \end{lstlisting}
 \item \textit{push()}, añade un elemento al final del array. El array original se modifica y aumenta su longitud en 1 elemento. (También es posible añadir más de un elemento a la vez):
 \begin{lstlisting}[style=JavaScriptTiny]
 var array = [1, 2, 3]; 
 array.push(4);
 // ahora array = [1, 2, 3, 4]
 \end{lstlisting}
 \item \textit{shift()}, elimina el primer elemento del array y lo devuelve. El array original se ve modificado y su longitud disminuida en 1 elemento:
 \begin{lstlisting}[style=JavaScriptTiny]
 var array = [1, 2, 3];
 var primero = array.shift();
 // ahora array = [2, 3], primero = 1
 \end{lstlisting}
 \item \textit{unshift()}, añade un elemento al principio del array. El array original se modifica y aumenta su longitud en 1 elemento. (También es posible añadir más de un elemento a la vez):
 \begin{lstlisting}[style=JavaScriptTiny]
 var array = [1, 2, 3];
 array.unshift(0);
 // ahora array = [0, 1, 2, 3] 
 \end{lstlisting}
 \item \textit{reverse()}, modifica un array colocando sus elementos en el orden inverso a su posición original:
 \begin{lstlisting}[style=JavaScriptTiny]
 var array = [1, 2, 3];
 array.reverse();
 // ahora array = [3, 2, 1]  
 \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Funciones útiles para números}
\begin{itemize}
 \item A continuación se muestran algunas de las funciones y propiedades más útiles para el manejo de números.
 \item \textit{NaN}, (del inglés, "Not a Number") JavaScript emplea el valor NaN para indicar un valor numérico no definido (por ejemplo, la división 0/0):
 \begin{lstlisting}[style=JavaScriptTiny]
 var numero1 = 0;
 var numero2 = 0;
 alert(numero1/numero2); // se muestra el valor NaN  
 \end{lstlisting}
 \item \textit{isNaN()}, permite proteger a la aplicación de posibles valores numéricos no definidos:
 \begin{lstlisting}[style=JavaScriptTiny]
 var numero1 = 0;
 var numero2 = 0;
 if(isNaN(numero1/numero2)) {
 alert("La division no esta definida para los numeros indicados");
 }
 else {
 alert("La division es igual a => " + numero1/numero2);
 }
 \end{lstlisting}
 \item \textit{Infinity}, hace referencia a un valor numérico infinito y positivo (también existe el valor –Infinity para los infinitos negativos):
 \begin{lstlisting}[style=JavaScriptTiny]
 var numero1 = 10;
 var numero2 = 0;
 alert(numero1/numero2); // se muestra el valor Infinity  
 \end{lstlisting}
 \item \textit{toFixed(digitos)}, devuelve el número original con tantos decimales como los indicados por el parámetro digitos y realiza los redondeos necesarios. Se trata de una función muy útil por ejemplo para mostrar precios:
 \begin{lstlisting}[style=JavaScriptTiny]
 var numero1 = 4564.34567;
 numero1.toFixed(2); // 4564.35
 numero1.toFixed(6); // 4564.345670
 numero1.toFixed(); // 4564
 \end{lstlisting}
\end{itemize}
\end{frame}


\subsection{JSON}
\begin{frame}[fragile]\frametitle{JSON}
\begin{itemize}
 \item JavaScript Object Notation (JSON) es un formato de intercambio de datos muy ligero y está basdo en la notación para la representación de objetos.
 \item A pesar de estar basado en JavaScript, es independiente del lenguaje.
 \item Puede ser utilizado para intercambiar datos entre programas escritos en lenguajes totalmente diferentes.
 \item Es un formato de texto, por lo que puede ser leído por máquinas y humanos, he implementado de una manera muy sencilla. 
 \item Para acceder a toda la información sobre JSON, acceder a \textit{http://www.JSON.org/.}
\end{itemize}
\end{frame}


\begin{frame}[fragile,allowframebreaks]\frametitle{Sintaxis JSON}
\begin{itemize}
 \item JSON define seis tipos de valores: \textit{objects, arrays, strings, numbers, booleans y el valor especial null.}
 \item Los espacios (espacios en blanco, tabuladores, retornos de carro y nueva línea) pueden introducirse antes o después de cualquier valor, sin afectar a los valores representados. 
 \item Esto hace que un texto JSON sea mucho más fácil de leer por humanos.
 \item Un objeto JSON es un contenedor, no ordenado de parejas clave/valor. 
 \item Una clave puede ser un string, y un valor puede ser un valor JSON (tanto un array como un objeto). 
 \item Los objetos JSON se pueden anidar hasta cualquier profundidad.
 \item Un array JSON es una secuencia ordenada de valores, donde un valor puede ser un valor JSON (tanto un array como un objeto).
 \item La gran mayoría de lenguajes incluyen características para trabajar de manera cómoda con valores JSON en ambos sentidos: partiendo de un objeto u array para convertirlo a una cadena de caracteres, o a partir de una cadena de caracteres, obtener los valores JSON.
 \item La sintaxis de los valores JSON es la siguiente:
 \begin{lstlisting}[style=JavaScriptTiny]
  "firstName":"John"
 \end{lstlisting}
 \item Los nombres JSON requieren comillas dobles.
 \item \textbf{Objetos JSON:}
 \item Los objetos JSON se escriben dentro de llaves.
 \item Al igual que JavaScript, los objetos JSON pueden contener múltiples pares de nombre / valores:
 \begin{lstlisting}[style=JavaScriptTiny]
  {"firstName":"John", "lastName":"Doe"}
 \end{lstlisting} 
 \item \textbf{Los Arrays en JSON:}
 \item Los arrays en JSON se escriben entre corchetes.
 \item Al igual que JavaScript, una array JSON puede contener varios objetos:
 \begin{lstlisting}[style=JavaScriptTiny]
  "employees":[
    {"firstName":"John", "lastName":"Doe"}, 
    {"firstName":"Anna", "lastName":"Smith"}, 
    {"firstName":"Peter","lastName":"Jones"}
  ]
 \end{lstlisting}
 \item En el ejemplo anterior, el objeto "employees" es un array que contiene tres objetos. 
 \item Cada objeto es un registro de una persona (con un nombre y un apellido).
 \item \textbf{Sintaxis JSON utilizada en JavaScript:}
 \item Debido a que la sintaxis JSON se deriva de la notación de objetos en JavaScript, es muy sencillo implementarlo.
 \item Con JavaScript se puede crear un array de objetos y asignar los datos a la misma, así:
 \begin{lstlisting}[style=JavaScriptTiny]
  var employees = [
    {"firstName":"John", "lastName":"Doe"},
    {"firstName":"Anna", "lastName":"Smith"},
    {"firstName":"Peter","lastName": "Jones"}
 ];
 \end{lstlisting}
 \item Se puede acceder a la primera entrada del array del objeto JavaScript de la siguiente manera:
 \begin{lstlisting}[style=JavaScriptTiny]
  // returns John Doe
 employees[0].firstName + " " + employees[0].lastName;
 \end{lstlisting}
 \item También se puede acceder de esta otra manera:
 \begin{lstlisting}[style=JavaScriptTiny]
  // returns John Doe
 employees[0]["firstName"] + " " + employees[0]["lastName"];
 \end{lstlisting}

\end{itemize}
\end{frame}

\subsection{DOM}
\begin{frame}[fragile,allowframebreaks]\frametitle{Document Object Model}
\begin{itemize}
 \item La creación del Document Object Model o \textbf{DOM} es una de las innovaciones que más ha influido en el desarrollo de las páginas web dinámicas y de las aplicaciones web más complejas.
 \item DOM permite a los programadores web acceder y manipular las páginas XHTML como si fueran documentos XML.
 \item De hecho, DOM se diseñó originalmente para manipular de forma sencilla los documentos XML.
 \item A pesar de sus orígenes, DOM se ha convertido en una utilidad disponible para la mayoría de lenguajes de programación (Java, PHP, JavaScript) y cuyas únicas diferencias se encuentran en la forma de implementarlo.
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Árbol de nodos}
\begin{itemize}
 \item Una de las tareas habituales en la programación de aplicaciones web con JavaScript consiste en la manipulación de las páginas web.
 \item De esta forma, es habitual obtener el valor almacenado por algunos elementos (por ejemplo los elementos de un formulario), crear un elemento (párrafos, <div>, etc.) de forma dinámica y añadirlo a la página, aplicar una animación a un elemento (que aparezca/desaparezca, que se desplace, etc.).
 \item Todas estas tareas habituales son muy sencillas de realizar gracias a DOM.
 \item Sin embargo, para poder utilizar las utilidades de DOM, es necesario "transformar" la página original. 
 \item Una página xHTML normal no es más que una sucesión de caracteres, por lo que es un formato muy difícil de manipular. 
 \item Por ello, los navegadores web transforman automáticamente todas las páginas web en una estructura más eficiente de manipular.
 \item Esta transformación la realizan todos los navegadores de forma automática y nos permite utilizar las herramientas de DOM de forma muy sencilla.
 \item El motivo por el que se muestra el funcionamiento de esta transformación interna es que condiciona el comportamiento de DOM y por tanto, la forma en la que se manipulan las páginas.
 \item DOM transforma todos los documentos XHTML en un conjunto de elementos llamados nodos, que están interconectados y que representan los contenidos de las páginas web y las relaciones entre ellos. 
 \item Por su aspecto, la unión de todos los nodos se llama "árbol de nodos".
 \item La siguiente página XHTML sencilla:
 \begin{lstlisting}[style=JavaScriptTiny]
  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
  <html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>Pagina sencilla</title>
  </head>
  
  <body>
  <p>Esta pagina es <strong>muy sencilla</strong></p>
  </body>
  </html>
 \end{lstlisting}
 \item Se transforma en el siguiente árbol de nodos:
%  \includegraphics [width=0.85\textwidth,height=0.6\textheight]{\webrtcdir/figures/arbol-de-nodos}
 \begin{itemize}
  \item \textit{\textbf{Figura 1.} Árbol de nodos generado automáticamente por DOM a partir del código XHTML de la página.}
 \end{itemize}
 \item En el esquema anterior, cada rectángulo representa un nodo DOM y las flechas indican las relaciones entre nodos.
 \item Dentro de cada nodo, se ha incluido su tipo (que se verá más adelante) y su contenido.
 \item La raíz del árbol de nodos de cualquier página XHTML siempre es la misma: un nodo de tipo especial denominado \textbf{"Documento".}
 \item A partir de ese nodo raíz, cada etiqueta XHTML se transforma en un nodo de tipo \textbf{"Elemento"}.
 \item La conversión de etiquetas en nodos se realiza de forma jerárquica.
 \item De esta forma, del nodo raíz solamente pueden derivar los nodos \textbf{HEAD} y \textbf{BODY.}
 \item A partir de esta derivación inicial, cada etiqueta XHTML se transforma en un nodo que deriva del nodo correspondiente a su "etiqueta padre".
 \item La transformación de las etiquetas XHTML habituales genera dos nodos: el primero es el nodo de tipo "Elemento" (correspondiente a la propia etiqueta XHTML) y el segundo es un nodo de tipo "Texto" que contiene el texto encerrado por esa etiqueta XHTML.
 \item Así, la siguiente etiqueta XHTML:
 \begin{lstlisting}[style=JavaScriptTiny]
 <title>Pagina sencilla</title>
 \end{lstlisting}
 \item Genera los siguientes dos nodos:
%  \includegraphics [width=0.85\textwidth]{\webrtcdir/figures/un-nodo}    
 \begin{itemize}
  \item \textit{\textbf{Figura 2.} Nodos generados automáticamente por DOM para una etiqueta XHTML sencilla.}
 \end{itemize}
 \item De la misma forma, la siguiente etiqueta XHTML:
 \begin{lstlisting}[style=JavaScriptTiny]
 <p>Esta pagina es <strong>muy sencilla</strong></p>
 \end{lstlisting}
 \item Genera los siguientes nodos:
 \begin{itemize}
  \item Nodo de tipo "Elemento" correspondiente a la etiqueta <p>.
  \item Nodo de tipo "Texto" con el contenido textual de la etiqueta <p>.
  \item Como el contenido de <p> incluye en su interior otra etiqueta XHTML, la etiqueta interior se transforma en un nodo de tipo "Elemento" que representa la etiqueta <strong> y que deriva del nodo anterior.
  \item El contenido de la etiqueta <strong> genera a su vez otro nodo de tipo "Texto" que deriva del nodo generado por <strong>.
 \end{itemize}
%  \includegraphics [width=0.85\textwidth]{\webrtcdir/figures/dos-nodos}
 \begin{itemize}
  \item \textit{\textbf{Figura 3.}  Nodos generados automáticamente por DOM para una etiqueta XHTML con otras etiquetas XHTML en su interior.}
 \end{itemize}
 \item La transformación automática de la página en un árbol de nodos siempre sigue las mismas reglas:
 \begin{itemize}
  \item Las etiquetas XHTML se transforman en dos nodos: el primero es la propia etiqueta y el segundo nodo es hijo del primero y consiste en el contenido textual de la etiqueta.
  \item Si una etiqueta XHTML se encuentra dentro de otra, se sigue el mismo procedimiento anterior, pero los nodos generados serán nodos hijo de su etiqueta padre.
 \end{itemize}
 \framebreak
 \item Como se puede suponer, las páginas XHTML habituales producen árboles con miles de nodos. 
 \item Sin embargo, el proceso de transformación es rápido y automático, siendo las funciones proporcionadas por DOM (que se verán más adelante) las únicas que permiten acceder a cualquier nodo de la página de forma sencilla e inmediata. 
\end{itemize}
\end{frame}

\begin{frame}[fragile]\frametitle{Tipo de nodos}
\begin{itemize}
 \item La especificación completa de DOM define 12 tipos de nodos.
 \item Las páginas XHTML habituales se pueden manipular manejando solamente cuatro o cinco tipos de nodos:
 \begin{itemize}
  \item \textbf{Document}, nodo raíz del que derivan todos los demás nodos del árbol.
  \item \textbf{Element}, representa cada una de las etiquetas XHTML. Se trata del único nodo que puede contener atributos y el único del que pueden derivar otros nodos.
  \item \textbf{Attr}, se define un nodo de este tipo para representar cada uno de los atributos de las etiquetas XHTML, es decir, uno por cada par atributo=valor.
  \item \textbf{Text}, nodo que contiene el texto encerrado por una etiqueta XHTML.
  \item \textbf{Comment}, representa los comentarios incluidos en la página XHTML.
 \end{itemize}

\end{itemize}
\end{frame}


\begin{frame}[fragile,allowframebreaks]\frametitle{Acceso directo a los nodos}
\begin{itemize}
 \item Una vez construido automáticamente el árbol completo de nodos DOM, ya es posible utilizar las funciones DOM para acceder de forma directa a cualquier nodo del árbol.
 \item Como acceder a un nodo del árbol es equivalente a acceder a "un trozo" de la página, una vez construido el árbol, ya es posible manipular de forma sencilla la página: 
 \item acceder al valor de un elemento, establecer el valor de un elemento, mover un elemento de la página, crear y añadir nuevos elementos, etc.
 \item DOM proporciona dos métodos alternativos para acceder a un nodo específico: 
 \framebreak
 \item \textbf{A través de sus nodos padre:}
 \begin{itemize}
  \item Consisten en acceder al nodo raíz de la página y después a sus nodos hijos y a los nodos hijos de esos hijos y así sucesivamente hasta el último nodo de la rama terminada por el nodo buscado. 
 \end{itemize}
 \item \textbf{Acceso directo:}
 \begin{itemize}
  \item Cuando se quiere acceder a un nodo específico, es mucho más rápido acceder directamente a ese nodo y no llegar hasta él descendiendo a través de todos sus nodos padre.
  \item Por ese motivo, vamos a presentar solo las funciones que permiten acceder de forma directa a los nodos.
 \end{itemize}
 \item Por último, es importante recordar que el acceso a los nodos, su modificación y su eliminación solamente es posible cuando el árbol DOM ha sido construido completamente, es decir, después de que la página XHTML se cargue por completo.
 \item \textbf{getElementsByTagName():}
 \begin{itemize}
  \item La función getElementsByTagName(nombreEtiqueta) obtiene todos los elementos de la página XHTML cuya etiqueta sea igual que el parámetro que se le pasa a la función.
  \item El siguiente ejemplo muestra cómo obtener todos los párrafos de una página XHTML:
  \begin{lstlisting}[style=JavaScriptTiny]
  var parrafos = document.getElementsByTagName("p"); 
  \end{lstlisting}
  \item El valor que se indica delante del nombre de la función (en este caso, document) es el nodo a partir del cual se realiza la búsqueda de los elementos. 
  \item En este caso, como se quieren obtener todos los párrafos de la página, se utiliza el valor document como punto de partida de la búsqueda.
  \item El valor que devuelve la función es un array con todos los nodos que cumplen la condición de que su etiqueta coincide con el parámetro proporcionado.
  \item El valor devuelto es un array de nodos DOM, no un array de cadenas de texto o un array de objetos normales.
  \item Por lo tanto, se debe procesar cada valor del array de la forma que se muestra en las siguientes secciones.
  \item De este modo, se puede obtener el primer párrafo de la página de la siguiente manera:
  \begin{lstlisting}[style=JavaScriptTiny]
  var primerParrafo = parrafos[0];
  \end{lstlisting}
  \item De la misma forma, se podrían recorrer todos los párrafos de la página con el siguiente código:
  \begin{lstlisting}[style=JavaScriptTiny]
  for(var i=0; i<parrafos.length; i++) {
    var parrafo = parrafos[i];
  }
  \end{lstlisting}
  \item La función getElementsByTagName() se puede aplicar de forma recursiva sobre cada uno de los nodos devueltos por la función.
  \item En el siguiente ejemplo, se obtienen todos los enlaces del primer párrafo de la página:
  \begin{lstlisting}[style=JavaScriptTiny]
   var parrafos = document.getElementsByTagName("p");
   var primerParrafo = parrafos[0];
   var enlaces = primerParrafo.getElementsByTagName("a");
  \end{lstlisting}
 \end{itemize}
 \item \textbf{getElementsByName():}
 \begin{itemize}
  \item La función getElementsByName() es similar a la anterior, pero en este caso se buscan los elementos cuyo atributo \textit{name} sea igual al parámetro proporcionado. 
  \item En el siguiente ejemplo, se obtiene directamente el único párrafo con el nombre indicado:
  \begin{lstlisting}[style=JavaScriptTiny]
  var parrafoEspecial = document.getElementsByName("especial");
 
  <p name="prueba">...</p>
  <p name="especial">...</p>
  <p>...</p> 
  \end{lstlisting}
  \item Normalmente el atributo name es único para los elementos HTML que lo definen, por lo que es un método muy práctico para acceder directamente al nodo deseado.
  \item En el caso de los elementos HTML radiobutton, el atributo name es común a todos los radiobutton que están relacionados, por lo que la función devuelve una colección de elementos.
 \end{itemize}
 \item \textbf{getElementById():}
 \begin{itemize}
  \item La función getElementById() es la más utilizada cuando se desarrollan aplicaciones web dinámicas.
  \item Se trata de la función preferida para acceder directamente a un nodo y poder leer o modificar sus propiedades.
  \item La función getElementById() devuelve el elemento XHTML cuyo atributo \textbf{id} coincide con el parámetro indicado en la función.
  \item Como el atributo id debe ser único para cada elemento de una misma página, la función devuelve únicamente el nodo deseado.
  \begin{lstlisting}[style=JavaScriptTiny]
  var cabecera = document.getElementById("cabecera");
 
  <div id="cabecera">
    <a href="/" id="logo">...</a>
  </div> 
  \end{lstlisting}
  
 \end{itemize}

\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Creación y eliminación de nodos}
\begin{itemize}
 \item Acceder a los nodos y a sus propiedades es sólo una parte de las manipulaciones habituales en las páginas. 
 \item Las otras operaciones habituales son las de crear y eliminar nodos del árbol DOM, es decir, crear y eliminar "trozos" de la página web.
 \item \textbf{Creación de elementos XHTML simples:}
 \begin{itemize}
  \item Como se ha visto, un elemento XHTML sencillo, como por ejemplo un párrafo, genera dos nodos:
  \begin{itemize}
   \item El primer nodo es de tipo \textit{Element} y representa la etiqueta \textbf{<p>}.
   \item El segundo nodo es de tipo \textit{Text} y representa el contenido \textbf{textual} de la etiqueta <p>.
  \end{itemize}
  \framebreak
  \item Por este motivo, crear y añadir a la página un nuevo elemento XHTML sencillo consta de cuatro pasos diferentes:
  \begin{itemize}
   \item Creación de un nodo de tipo Element que represente al elemento.
   \item Creación de un nodo de tipo Text que represente el contenido del elemento.
   \item Añadir el nodo Text como nodo hijo del nodo Element.
   \item Añadir el nodo Element a la página, en forma de nodo hijo del nodo correspondiente al lugar en el que se quiere insertar el elemento.
  \end{itemize}
  \item De este modo, si se quiere añadir un párrafo simple al final de una página XHTML, es necesario incluir el siguiente código JavaScript:
  \begin{lstlisting}[style=JavaScriptTiny]
  // Crear nodo de tipo Element
  var parrafo = document.createElement("p");
  
  // Crear nodo de tipo Text
  var contenido = document.createTextNode("Hola Mundo!");
  
  // Anadir el nodo Text como hijo del nodo Element
  parrafo.appendChild(contenido);
  
  // Anadir el nodo Element como hijo de la pagina
  document.body.appendChild(parrafo);   
  \end{lstlisting}
  \item El proceso de creación de nuevos nodos puede llegar a ser tedioso, ya que implica la utilización de tres funciones DOM:
  \begin{itemize}
   \item \textbf{createElement(etiqueta):} crea un nodo de tipo Element que representa al elemento XHTML cuya etiqueta se pasa como parámetro.
   \item \textbf{createTextNode(contenido):} crea un nodo de tipo Text que almacena el contenido textual de los elementos XHTML.
   \item \textbf{nodoPadre.appendChild(nodoHijo):} añade un nodo como hijo de otro nodo. Se debe utilizar al menos dos veces con los nodos habituales, tal y como lo indica nuestro ejemplo anterior.
  \end{itemize}
 \end{itemize}
 \item \textbf{Eliminación de nodos:}
 \begin{itemize}
  \item Afortunadamente, eliminar un nodo del árbol DOM de la página es mucho más sencillo que añadirlo. 
  \item En este caso, solamente es necesario utilizar la función \textbf{removeChild()}:
  \begin{lstlisting}[style=JavaScriptTiny]
  var parrafo = document.getElementById("provisional");
  parrafo.parentNode.removeChild(parrafo);
  
  <p id="provisional">...</p> 
  \end{lstlisting}
  \item La función removeChild() requiere como parámetro el nodo que se va a eliminar.
  \item Además, esta función debe ser invocada desde el elemento padre de ese nodo que se quiere eliminar.
  \item La forma más segura y rápida de acceder al nodo padre de un elemento es mediante la propiedad \textbf{nodoHijo.parentNode}.
  \item Así, para eliminar un nodo de una página XHTML se invoca a la función \textbf{removeChild()} desde el valor \textbf{parentNode} del nodo que se quiere eliminar.
  \item Cuando se elimina un nodo, también se eliminan automáticamente todos los nodos hijos que tenga, por lo que no es necesario borrar manualmente cada nodo hijo.
 \end{itemize} 
\end{itemize}
\end{frame}

\begin{frame}[fragile,allowframebreaks]\frametitle{Acceso directo a los atributos XHTML}
\begin{itemize}
 \item Una vez que se ha accedido a un nodo, el siguiente paso natural consiste en acceder y/o modificar sus atributos y propiedades.
 \item Mediante DOM, es posible acceder de forma sencilla a todos los atributos XHTML y todas las propiedades \textbf{CSS} de cualquier elemento de la página.
 \item Los atributos XHTML de los elementos de la página se transforman automáticamente en propiedades de los nodos. 
 \item Para acceder a su valor, simplemente se indica el nombre del atributo XHTML detrás del nombre del nodo.
 \item El siguiente ejemplo obtiene de forma directa la dirección a la que enlaza el enlace:
 \begin{lstlisting}[style=JavaScriptTiny]
 var enlace = document.getElementById("enlace");
 alert(enlace.href); // muestra http://www...com
  
 <a id="enlace" href="http://www...com">Enlace</a> 
 \end{lstlisting}
 \item En el ejemplo anterior, se obtiene el nodo DOM que representa el enlace mediante la función \textbf{document.getElementById()}.
 \item A continuación, se obtiene el atributo \textbf{href} del enlace mediante \textit{enlace.href}. 
 \item Para obtener por ejemplo el atributo id, se utilizaría enlace.id.
 \item Las propiedades \textbf{CSS} no son tan fáciles de obtener como los atributos XHTML. 
 \item Para obtener el valor de cualquier propiedad CSS del nodo, se debe utilizar el atributo \textbf{style}.
 \item El siguiente ejemplo obtiene el valor de la propiedad margin de la imagen:
 \begin{lstlisting}[style=JavaScriptTiny]
 var imagen = document.getElementById("imagen");
 alert(imagen.style.margin);
  
 <img id="imagen" style="margin:0; border:0;" src="logo.png" /> 
 \end{lstlisting}
 \item Si el nombre de una propiedad CSS es compuesto, se accede a su valor modificando ligeramente su nombre:
 \begin{lstlisting}[style=JavaScriptTiny]
 var parrafo = document.getElementById("parrafo");
 alert(parrafo.style.fontWeight);  // muestra "bold"
 
 <p id="parrafo" style="font-weight: bold;">...</p>
 \end{lstlisting}
 \item La transformación del nombre de las propiedades CSS compuestas consiste en eliminar todos los guiones medios (-) y escribir en mayúscula la letra siguiente a cada guión medio. 
 \item A continuación se muestran algunos ejemplos:
 \begin{itemize}
  \item font-weight se transforma en fontWeight.
  \item line-height se transforma en lineHeight.
  \item border-top-style se transforma en borderTopStyle.
  \item list-style-image se transforma en listStyleImage.
 \end{itemize}
 \item El único atributo XHTML que no tiene el mismo nombre en XHTML y en las propiedades DOM es el atributo \textbf{class}.
 \item Como la palabra class está reservada por JavaScript, no es posible utilizarla para acceder al atributo class del elemento XHTML.
 \item En su lugar, DOM utiliza el nombre className para acceder al atributo class de XHTML:
 \begin{lstlisting}[style=JavaScriptTiny]
  var parrafo = document.getElementById("parrafo");
  alert(parrafo.class); // muestra "undefined"
  alert(parrafo.className); // muestra "normal"
  
  <p id="parrafo" class="normal">...</p> 
 \end{lstlisting}
\end{itemize}
\end{frame}
